{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.4.6 (2024-07-08)\n *\n * Highcharts\n *\n * (c) 2010-2024 Highsoft AS\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/data-tools', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                Highcharts.win.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Data/Modifiers/DataModifier.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *  - GÃ¸ran Slettemark\n         *\n         * */\n        const { addEvent, fireEvent, merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Abstract class to provide an interface for modifying a table.\n         *\n         */\n        class DataModifier {\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Runs a timed execution of the modifier on the given datatable.\n             * Can be configured to run multiple times.\n             *\n             * @param {DataTable} dataTable\n             * The datatable to execute\n             *\n             * @param {DataModifier.BenchmarkOptions} options\n             * Options. Currently supports `iterations` for number of iterations.\n             *\n             * @return {Array<number>}\n             * An array of times in milliseconds\n             *\n             */\n            benchmark(dataTable, options) {\n                const results = [];\n                const modifier = this;\n                const execute = () => {\n                    modifier.modifyTable(dataTable);\n                    modifier.emit({\n                        type: 'afterBenchmarkIteration'\n                    });\n                };\n                const defaultOptions = {\n                    iterations: 1\n                };\n                const { iterations } = merge(defaultOptions, options);\n                modifier.on('afterBenchmarkIteration', () => {\n                    if (results.length === iterations) {\n                        modifier.emit({\n                            type: 'afterBenchmark',\n                            results\n                        });\n                        return;\n                    }\n                    // Run again\n                    execute();\n                });\n                const times = {\n                    startTime: 0,\n                    endTime: 0\n                };\n                // Add timers\n                modifier.on('modify', () => {\n                    times.startTime = window.performance.now();\n                });\n                modifier.on('afterModify', () => {\n                    times.endTime = window.performance.now();\n                    results.push(times.endTime - times.startTime);\n                });\n                // Initial run\n                execute();\n                return results;\n            }\n            /**\n             * Emits an event on the modifier to all registered callbacks of this event.\n             *\n             * @param {DataModifier.Event} [e]\n             * Event object containing additonal event information.\n             */\n            emit(e) {\n                fireEvent(this, e.type, e);\n            }\n            /**\n             * Returns a modified copy of the given table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to modify.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Promise<Highcharts.DataTable>}\n             * Table with `modified` property as a reference.\n             */\n            modify(table, eventDetail) {\n                const modifier = this;\n                return new Promise((resolve, reject) => {\n                    if (table.modified === table) {\n                        table.modified = table.clone(false, eventDetail);\n                    }\n                    try {\n                        resolve(modifier.modifyTable(table, eventDetail));\n                    }\n                    catch (e) {\n                        modifier.emit({\n                            type: 'error',\n                            detail: eventDetail,\n                            table\n                        });\n                        reject(e);\n                    }\n                });\n            }\n            /**\n             * Applies partial modifications of a cell change to the property `modified`\n             * of the given modified table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {string} columnName\n             * Column name of changed cell.\n             *\n             * @param {number|undefined} rowIndex\n             * Row index of changed cell.\n             *\n             * @param {Highcharts.DataTableCellType} cellValue\n             * Changed cell value.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyCell(table, \n            /* eslint-disable @typescript-eslint/no-unused-vars */\n            columnName, rowIndex, cellValue, eventDetail\n            /* eslint-enable @typescript-eslint/no-unused-vars */\n            ) {\n                return this.modifyTable(table);\n            }\n            /**\n             * Applies partial modifications of column changes to the property\n             * `modified` of the given table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {Highcharts.DataTableColumnCollection} columns\n             * Changed columns as a collection, where the keys are the column names.\n             *\n             * @param {number} [rowIndex=0]\n             * Index of the first changed row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyColumns(table, \n            /* eslint-disable @typescript-eslint/no-unused-vars */\n            columns, rowIndex, eventDetail\n            /* eslint-enable @typescript-eslint/no-unused-vars */\n            ) {\n                return this.modifyTable(table);\n            }\n            /**\n             * Applies partial modifications of row changes to the property `modified`\n             * of the given table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n             * Changed rows.\n             *\n             * @param {number} [rowIndex]\n             * Index of the first changed row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyRows(table, \n            /* eslint-disable @typescript-eslint/no-unused-vars */\n            rows, rowIndex, eventDetail\n            /* eslint-enable @typescript-eslint/no-unused-vars */\n            ) {\n                return this.modifyTable(table);\n            }\n            /**\n             * Registers a callback for a specific modifier event.\n             *\n             * @param {string} type\n             * Event type as a string.\n             *\n             * @param {DataEventEmitter.Callback} callback\n             * Function to register for an modifier callback.\n             *\n             * @return {Function}\n             * Function to unregister callback from the modifier event.\n             */\n            on(type, callback) {\n                return addEvent(this, type, callback);\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        /**\n         * Additionally provided types for modifier events and options.\n         */\n        (function (DataModifier) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            /**\n             * Registry as a record object with modifier names and their class\n             * constructor.\n             */\n            DataModifier.types = {};\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Adds a modifier class to the registry. The modifier class has to provide\n             * the `DataModifier.options` property and the `DataModifier.modifyTable`\n             * method to modify the table.\n             *\n             * @private\n             *\n             * @param {string} key\n             * Registry key of the modifier class.\n             *\n             * @param {DataModifierType} DataModifierClass\n             * Modifier class (aka class constructor) to register.\n             *\n             * @return {boolean}\n             * Returns true, if the registration was successful. False is returned, if\n             * their is already a modifier registered with this key.\n             */\n            function registerType(key, DataModifierClass) {\n                return (!!key &&\n                    !DataModifier.types[key] &&\n                    !!(DataModifier.types[key] = DataModifierClass));\n            }\n            DataModifier.registerType = registerType;\n        })(DataModifier || (DataModifier = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return DataModifier;\n    });\n    _registerModule(_modules, 'Data/DataTable.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *  - GÃ¸ran Slettemark\n         *  - Jomar HÃ¸nsi\n         *\n         * */\n        const { addEvent, fireEvent, uniqueKey } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Class to manage columns and rows in a table structure. It provides methods\n         * to add, remove, and manipulate columns and rows, as well as to retrieve data\n         * from specific cells.\n         *\n         * @class\n         * @name Highcharts.DataTable\n         *\n         * @param {Highcharts.DataTableOptions} [options]\n         * Options to initialize the new DataTable instance.\n         */\n        class DataTable {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * Tests whether a row contains only `null` values or is equal to\n             * DataTable.NULL. If all columns have `null` values, the function returns\n             * `true`. Otherwise, it returns `false` to indicate that the row contains\n             * at least one non-null value.\n             *\n             * @function Highcharts.DataTable.isNull\n             *\n             * @param {Highcharts.DataTableRow|Highcharts.DataTableRowObject} row\n             * Row to test.\n             *\n             * @return {boolean}\n             * Returns `true`, if the row contains only null, otherwise `false`.\n             *\n             * @example\n             * if (DataTable.isNull(row)) {\n             *   // handle null row\n             * }\n             */\n            static isNull(row) {\n                if (row === DataTable.NULL) {\n                    return true;\n                }\n                if (row instanceof Array) {\n                    if (!row.length) {\n                        return false;\n                    }\n                    for (let i = 0, iEnd = row.length; i < iEnd; ++i) {\n                        if (row[i] !== null) {\n                            return false;\n                        }\n                    }\n                }\n                else {\n                    const columnNames = Object.keys(row);\n                    if (!columnNames.length) {\n                        return false;\n                    }\n                    for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                        if (row[columnNames[i]] !== null) {\n                            return false;\n                        }\n                    }\n                }\n                return true;\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the DataTable class.\n             *\n             * @param {Highcharts.DataTableOptions} [options]\n             * Options to initialize the new DataTable instance.\n             */\n            constructor(options = {}) {\n                /**\n                 * Dictionary of all column aliases and their mapped column. If a column\n                 * for one of the get-methods matches an column alias, this column will\n                 * be replaced with the mapped column by the column alias.\n                 *\n                 * @name Highcharts.DataTable#aliases\n                 * @type {Highcharts.Dictionary<string>}\n                 */\n                this.aliases = (options.aliases ?\n                    JSON.parse(JSON.stringify(options.aliases)) :\n                    {});\n                /**\n                 * Whether the ID was automatic generated or given in the constructor.\n                 *\n                 * @name Highcharts.DataTable#autoId\n                 * @type {boolean}\n                 */\n                this.autoId = !options.id;\n                this.columns = {};\n                /**\n                 * ID of the table for identification purposes.\n                 *\n                 * @name Highcharts.DataTable#id\n                 * @type {string}\n                 */\n                this.id = (options.id || uniqueKey());\n                this.modified = this;\n                this.rowCount = 0;\n                this.versionTag = uniqueKey();\n                this.rowKeysId = options.rowKeysId;\n                const columns = options.columns || {}, columnNames = Object.keys(columns), thisColumns = this.columns;\n                let rowCount = 0;\n                for (let i = 0, iEnd = columnNames.length, column, columnName; i < iEnd; ++i) {\n                    columnName = columnNames[i];\n                    column = columns[columnName].slice();\n                    thisColumns[columnName] = column;\n                    rowCount = Math.max(rowCount, column.length);\n                }\n                for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                    thisColumns[columnNames[i]].length = rowCount;\n                }\n                this.rowCount = rowCount;\n                const aliases = options.aliases || {}, aliasKeys = Object.keys(aliases), thisAliases = this.aliases;\n                for (let i = 0, iEnd = aliasKeys.length, alias; i < iEnd; ++i) {\n                    alias = aliasKeys[i];\n                    thisAliases[alias] = aliases[alias];\n                }\n                this.setRowKeysColumn(rowCount);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Returns a clone of this table. The cloned table is completely independent\n             * of the original, and any changes made to the clone will not affect\n             * the original table.\n             *\n             * @function Highcharts.DataTable#clone\n             *\n             * @param {boolean} [skipColumns]\n             * Whether to clone columns or not.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Clone of this data table.\n             *\n             * @emits #cloneTable\n             * @emits #afterCloneTable\n             */\n            clone(skipColumns, eventDetail) {\n                const table = this, tableOptions = {};\n                table.emit({ type: 'cloneTable', detail: eventDetail });\n                if (!skipColumns) {\n                    tableOptions.aliases = table.aliases;\n                    tableOptions.columns = table.columns;\n                }\n                if (!table.autoId) {\n                    tableOptions.id = table.id;\n                }\n                if (table.rowKeysId) {\n                    tableOptions.rowKeysId = table.rowKeysId;\n                }\n                const tableClone = new DataTable(tableOptions);\n                if (!skipColumns) {\n                    tableClone.versionTag = table.versionTag;\n                }\n                table.emit({\n                    type: 'afterCloneTable',\n                    detail: eventDetail,\n                    tableClone\n                });\n                return tableClone;\n            }\n            /**\n             * Deletes a column alias and returns the original column name. If the alias\n             * is not found, the method returns `undefined`. Deleting an alias does not\n             * affect the data in the table, only the way columns are accessed.\n             *\n             * @function Highcharts.DataTable#deleteColumnAlias\n             *\n             * @param {string} alias\n             * The alias to delete.\n             *\n             * @return {string|undefined}\n             * Returns the original column name, if found.\n             */\n            deleteColumnAlias(alias) {\n                const table = this, aliases = table.aliases, deletedAlias = aliases[alias], modifier = table.modifier;\n                if (deletedAlias) {\n                    delete table.aliases[alias];\n                    if (modifier) {\n                        modifier.modifyColumns(table, { [deletedAlias]: new Array(table.rowCount) }, 0);\n                    }\n                }\n                return deletedAlias;\n            }\n            /**\n             * Deletes columns from the table.\n             *\n             * @function Highcharts.DataTable#deleteColumns\n             *\n             * @param {Array<string>} [columnNames]\n             * Names (no alias) of columns to delete. If no array is provided, all\n             * columns will be deleted.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTableColumnCollection|undefined}\n             * Returns the deleted columns, if found.\n             *\n             * @emits #deleteColumns\n             * @emits #afterDeleteColumns\n             */\n            deleteColumns(columnNames, eventDetail) {\n                const table = this, columns = table.columns, deletedColumns = {}, modifiedColumns = {}, modifier = table.modifier, rowCount = table.rowCount;\n                columnNames = (columnNames || Object.keys(columns));\n                if (columnNames.length) {\n                    table.emit({\n                        type: 'deleteColumns',\n                        columnNames,\n                        detail: eventDetail\n                    });\n                    for (let i = 0, iEnd = columnNames.length, column, columnName; i < iEnd; ++i) {\n                        columnName = columnNames[i];\n                        column = columns[columnName];\n                        if (column) {\n                            deletedColumns[columnName] = column;\n                            modifiedColumns[columnName] = new Array(rowCount);\n                        }\n                        delete columns[columnName];\n                    }\n                    let nColumns = Object.keys(columns).length;\n                    if (table.rowKeysId && nColumns === 1) {\n                        // All columns deleted, remove row keys column\n                        delete columns[table.rowKeysId];\n                        nColumns = 0;\n                    }\n                    if (!nColumns) {\n                        table.rowCount = 0;\n                    }\n                    if (modifier) {\n                        modifier.modifyColumns(table, modifiedColumns, 0, eventDetail);\n                    }\n                    table.emit({\n                        type: 'afterDeleteColumns',\n                        columns: deletedColumns,\n                        columnNames,\n                        detail: eventDetail\n                    });\n                    return deletedColumns;\n                }\n            }\n            /**\n             * Deletes rows in this table.\n             *\n             * @function Highcharts.DataTable#deleteRows\n             *\n             * @param {number} [rowIndex]\n             * Index to start delete of rows. If not specified, all rows will be\n             * deleted.\n             *\n             * @param {number} [rowCount=1]\n             * Number of rows to delete.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Array<Highcharts.DataTableRow>}\n             * Returns the deleted rows, if found.\n             *\n             * @emits #deleteRows\n             * @emits #afterDeleteRows\n             */\n            deleteRows(rowIndex, rowCount = 1, eventDetail) {\n                const table = this, deletedRows = [], modifiedRows = [], modifier = table.modifier;\n                table.emit({\n                    type: 'deleteRows',\n                    detail: eventDetail,\n                    rowCount,\n                    rowIndex: (rowIndex || 0)\n                });\n                if (typeof rowIndex === 'undefined') {\n                    rowIndex = 0;\n                    rowCount = table.rowCount;\n                }\n                if (rowCount > 0 && rowIndex < table.rowCount) {\n                    const columns = table.columns, columnNames = Object.keys(columns);\n                    for (let i = 0, iEnd = columnNames.length, column, deletedCells; i < iEnd; ++i) {\n                        column = columns[columnNames[i]];\n                        deletedCells = column.splice(rowIndex, rowCount);\n                        if (!i) {\n                            table.rowCount = column.length;\n                        }\n                        for (let j = 0, jEnd = deletedCells.length; j < jEnd; ++j) {\n                            deletedRows[j] = (deletedRows[j] || []);\n                            deletedRows[j][i] = deletedCells[j];\n                        }\n                        modifiedRows.push(new Array(iEnd));\n                    }\n                }\n                if (modifier) {\n                    modifier.modifyRows(table, modifiedRows, (rowIndex || 0), eventDetail);\n                }\n                table.emit({\n                    type: 'afterDeleteRows',\n                    detail: eventDetail,\n                    rowCount,\n                    rowIndex: (rowIndex || 0),\n                    rows: deletedRows\n                });\n                return deletedRows;\n            }\n            /**\n             * Emits an event on this table to all registered callbacks of the given\n             * event.\n             * @private\n             *\n             * @param {DataTable.Event} e\n             * Event object with event information.\n             */\n            emit(e) {\n                const table = this;\n                switch (e.type) {\n                    case 'afterDeleteColumns':\n                    case 'afterDeleteRows':\n                    case 'afterSetCell':\n                    case 'afterSetColumns':\n                    case 'afterSetRows':\n                        table.versionTag = uniqueKey();\n                        break;\n                    default:\n                }\n                fireEvent(table, e.type, e);\n            }\n            /**\n             * Fetches a single cell value.\n             *\n             * @function Highcharts.DataTable#getCell\n             *\n             * @param {string} columnNameOrAlias\n             * Column name or alias of the cell to retrieve.\n             *\n             * @param {number} rowIndex\n             * Row index of the cell to retrieve.\n             *\n             * @return {Highcharts.DataTableCellType|undefined}\n             * Returns the cell value or `undefined`.\n             */\n            getCell(columnNameOrAlias, rowIndex) {\n                const table = this;\n                columnNameOrAlias = (table.aliases[columnNameOrAlias] ||\n                    columnNameOrAlias);\n                const column = table.columns[columnNameOrAlias];\n                if (column) {\n                    return column[rowIndex];\n                }\n            }\n            /**\n             * Fetches a cell value for the given row as a boolean.\n             *\n             * @function Highcharts.DataTable#getCellAsBoolean\n             *\n             * @param {string} columnNameOrAlias\n             * Column name or alias to fetch.\n             *\n             * @param {number} rowIndex\n             * Row index to fetch.\n             *\n             * @return {boolean}\n             * Returns the cell value of the row as a boolean.\n             */\n            getCellAsBoolean(columnNameOrAlias, rowIndex) {\n                const table = this;\n                columnNameOrAlias = (table.aliases[columnNameOrAlias] ||\n                    columnNameOrAlias);\n                const column = table.columns[columnNameOrAlias];\n                return !!(column && column[rowIndex]);\n            }\n            /**\n             * Fetches a cell value for the given row as a number.\n             *\n             * @function Highcharts.DataTable#getCellAsNumber\n             *\n             * @param {string} columnNameOrAlias\n             * Column name or alias to fetch.\n             *\n             * @param {number} rowIndex\n             * Row index to fetch.\n             *\n             * @param {boolean} [useNaN]\n             * Whether to return NaN instead of `null` and `undefined`.\n             *\n             * @return {number|null}\n             * Returns the cell value of the row as a number.\n             */\n            getCellAsNumber(columnNameOrAlias, rowIndex, useNaN) {\n                const table = this;\n                columnNameOrAlias = (table.aliases[columnNameOrAlias] ||\n                    columnNameOrAlias);\n                const column = table.columns[columnNameOrAlias];\n                let cellValue = (column && column[rowIndex]);\n                switch (typeof cellValue) {\n                    case 'boolean':\n                        return (cellValue ? 1 : 0);\n                    case 'number':\n                        return (isNaN(cellValue) && !useNaN ? null : cellValue);\n                }\n                cellValue = parseFloat(`${cellValue ?? ''}`);\n                return (isNaN(cellValue) && !useNaN ? null : cellValue);\n            }\n            /**\n             * Fetches a cell value for the given row as a string.\n             *\n             * @function Highcharts.DataTable#getCellAsString\n             *\n             * @param {string} columnNameOrAlias\n             * Column name or alias to fetch.\n             *\n             * @param {number} rowIndex\n             * Row index to fetch.\n             *\n             * @return {string}\n             * Returns the cell value of the row as a string.\n             */\n            getCellAsString(columnNameOrAlias, rowIndex) {\n                const table = this;\n                columnNameOrAlias = (table.aliases[columnNameOrAlias] ||\n                    columnNameOrAlias);\n                const column = table.columns[columnNameOrAlias];\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                return `${(column && column[rowIndex])}`;\n            }\n            /**\n             * Fetches the given column by the canonical column name or by an alias.\n             * This function is a simplified wrap of {@link getColumns}.\n             *\n             * @function Highcharts.DataTable#getColumn\n             *\n             * @param {string} columnNameOrAlias\n             * Name or alias of the column to get, alias takes precedence.\n             *\n             * @param {boolean} [asReference]\n             * Whether to return the column as a readonly reference.\n             *\n             * @return {Highcharts.DataTableColumn|undefined}\n             * A copy of the column, or `undefined` if not found.\n             */\n            getColumn(columnNameOrAlias, asReference) {\n                return this.getColumns([columnNameOrAlias], asReference)[columnNameOrAlias];\n            }\n            /**\n             * Fetches the given column by the canonical column name or by an alias, and\n             * validates the type of the first few cells. If the first defined cell is\n             * of type number, it assumes for performance reasons, that all cells are of\n             * type number or `null`. Otherwise it will convert all cells to number\n             * type, except `null`.\n             *\n             * @function Highcharts.DataTable#getColumnAsNumbers\n             *\n             * @param {string} columnNameOrAlias\n             * Name or alias of the column to get, alias takes precedence.\n             *\n             * @param {boolean} [useNaN]\n             * Whether to use NaN instead of `null` and `undefined`.\n             *\n             * @return {Array<(number|null)>}\n             * A copy of the column, or an empty array if not found.\n             */\n            getColumnAsNumbers(columnNameOrAlias, useNaN) {\n                const table = this, columns = table.columns;\n                columnNameOrAlias = (table.aliases[columnNameOrAlias] ||\n                    columnNameOrAlias);\n                const column = columns[columnNameOrAlias], columnAsNumber = [];\n                if (column) {\n                    const columnLength = column.length;\n                    if (useNaN) {\n                        for (let i = 0; i < columnLength; ++i) {\n                            columnAsNumber.push(table.getCellAsNumber(columnNameOrAlias, i, true));\n                        }\n                    }\n                    else {\n                        for (let i = 0, cellValue; i < columnLength; ++i) {\n                            cellValue = column[i];\n                            if (typeof cellValue === 'number') {\n                                // Assume unmixed data for performance reasons\n                                return column.slice();\n                            }\n                            if (cellValue !== null &&\n                                typeof cellValue !== 'undefined') {\n                                break;\n                            }\n                        }\n                        for (let i = 0; i < columnLength; ++i) {\n                            columnAsNumber.push(table.getCellAsNumber(columnNameOrAlias, i));\n                        }\n                    }\n                }\n                return columnAsNumber;\n            }\n            /**\n             * Fetches all column names.\n             *\n             * @function Highcharts.DataTable#getColumnNames\n             *\n             * @return {Array<string>}\n             * Returns all column names.\n             */\n            getColumnNames() {\n                const table = this, columnNames = Object.keys(table.columns);\n                this.removeRowKeysColumn(columnNames);\n                return columnNames;\n            }\n            /**\n             * Retrieves all or the given columns.\n             *\n             * @function Highcharts.DataTable#getColumns\n             *\n             * @param {Array<string>} [columnNamesOrAliases]\n             * Column names or aliases to retrieve. Aliases taking precedence.\n             *\n             * @param {boolean} [asReference]\n             * Whether to return columns as a readonly reference.\n             *\n             * @return {Highcharts.DataTableColumnCollection}\n             * Collection of columns. If a requested column was not found, it is\n             * `undefined`.\n             */\n            getColumns(columnNamesOrAliases, asReference) {\n                const table = this, tableAliasMap = table.aliases, tableColumns = table.columns, columns = {};\n                columnNamesOrAliases = (columnNamesOrAliases || Object.keys(tableColumns));\n                this.removeRowKeysColumn(columnNamesOrAliases);\n                for (let i = 0, iEnd = columnNamesOrAliases.length, column, columnName; i < iEnd; ++i) {\n                    columnName = columnNamesOrAliases[i];\n                    column = tableColumns[(tableAliasMap[columnName] || columnName)];\n                    if (column) {\n                        columns[columnName] = (asReference ? column : column.slice());\n                    }\n                }\n                return columns;\n            }\n            /**\n             * Retrieves the modifier for the table.\n             * @private\n             *\n             * @return {Highcharts.DataModifier|undefined}\n             * Returns the modifier or `undefined`.\n             */\n            getModifier() {\n                return this.modifier;\n            }\n            /**\n             * Retrieves the row at a given index. This function is a simplified wrap of\n             * {@link getRows}.\n             *\n             * @function Highcharts.DataTable#getRow\n             *\n             * @param {number} rowIndex\n             * Row index to retrieve. First row has index 0.\n             *\n             * @param {Array<string>} [columnNamesOrAliases]\n             * Column names or aliases in order to retrieve.\n             *\n             * @return {Highcharts.DataTableRow}\n             * Returns the row values, or `undefined` if not found.\n             */\n            getRow(rowIndex, columnNamesOrAliases) {\n                return this.getRows(rowIndex, 1, columnNamesOrAliases)[0];\n            }\n            /**\n             * Returns the number of rows in this table.\n             *\n             * @function Highcharts.DataTable#getRowCount\n             *\n             * @return {number}\n             * Number of rows in this table.\n             */\n            getRowCount() {\n                // @todo Implement via property getter `.length` browsers supported\n                return this.rowCount;\n            }\n            /**\n             * Retrieves the index of the first row matching a specific cell value.\n             *\n             * @function Highcharts.DataTable#getRowIndexBy\n             *\n             * @param {string} columnNameOrAlias\n             * Column to search in.\n             *\n             * @param {Highcharts.DataTableCellType} cellValue\n             * Cell value to search for. `NaN` and `undefined` are not supported.\n             *\n             * @param {number} [rowIndexOffset]\n             * Index offset to start searching.\n             *\n             * @return {number|undefined}\n             * Index of the first row matching the cell value.\n             */\n            getRowIndexBy(columnNameOrAlias, cellValue, rowIndexOffset) {\n                const table = this;\n                columnNameOrAlias = (table.aliases[columnNameOrAlias] ||\n                    columnNameOrAlias);\n                const column = table.columns[columnNameOrAlias];\n                if (column) {\n                    const rowIndex = column.indexOf(cellValue, rowIndexOffset);\n                    if (rowIndex !== -1) {\n                        return rowIndex;\n                    }\n                }\n            }\n            /**\n             * Retrieves the row at a given index. This function is a simplified wrap of\n             * {@link getRowObjects}.\n             *\n             * @function Highcharts.DataTable#getRowObject\n             *\n             * @param {number} rowIndex\n             * Row index.\n             *\n             * @param {Array<string>} [columnNamesOrAliases]\n             * Column names or aliases and their order to retrieve.\n             *\n             * @return {Highcharts.DataTableRowObject}\n             * Returns the row values, or `undefined` if not found.\n             */\n            getRowObject(rowIndex, columnNamesOrAliases) {\n                return this.getRowObjects(rowIndex, 1, columnNamesOrAliases)[0];\n            }\n            /**\n             * Fetches all or a number of rows.\n             *\n             * @function Highcharts.DataTable#getRowObjects\n             *\n             * @param {number} [rowIndex]\n             * Index of the first row to fetch. Defaults to first row at index `0`.\n             *\n             * @param {number} [rowCount]\n             * Number of rows to fetch. Defaults to maximal number of rows.\n             *\n             * @param {Array<string>} [columnNamesOrAliases]\n             * Column names or aliases and their order to retrieve.\n             *\n             * @return {Highcharts.DataTableRowObject}\n             * Returns retrieved rows.\n             */\n            getRowObjects(rowIndex = 0, rowCount = (this.rowCount - rowIndex), columnNamesOrAliases) {\n                const table = this, aliases = table.aliases, columns = table.columns, rows = new Array(rowCount);\n                columnNamesOrAliases = (columnNamesOrAliases || Object.keys(columns));\n                this.removeRowKeysColumn(columnNamesOrAliases);\n                for (let i = rowIndex, i2 = 0, iEnd = Math.min(table.rowCount, (rowIndex + rowCount)), column, row; i < iEnd; ++i, ++i2) {\n                    row = rows[i2] = {};\n                    for (const columnName of columnNamesOrAliases) {\n                        column = columns[(aliases[columnName] || columnName)];\n                        row[columnName] = (column ? column[i] : void 0);\n                    }\n                }\n                return rows;\n            }\n            /**\n             * Fetches all or a number of rows.\n             *\n             * @function Highcharts.DataTable#getRows\n             *\n             * @param {number} [rowIndex]\n             * Index of the first row to fetch. Defaults to first row at index `0`.\n             *\n             * @param {number} [rowCount]\n             * Number of rows to fetch. Defaults to maximal number of rows.\n             *\n             * @param {Array<string>} [columnNamesOrAliases]\n             * Column names or aliases and their order to retrieve.\n             *\n             * @return {Highcharts.DataTableRow}\n             * Returns retrieved rows.\n             */\n            getRows(rowIndex = 0, rowCount = (this.rowCount - rowIndex), columnNamesOrAliases) {\n                const table = this, aliases = table.aliases, columns = table.columns, rows = new Array(rowCount);\n                columnNamesOrAliases = (columnNamesOrAliases || Object.keys(columns));\n                for (let i = rowIndex, i2 = 0, iEnd = Math.min(table.rowCount, (rowIndex + rowCount)), column, row; i < iEnd; ++i, ++i2) {\n                    row = rows[i2] = [];\n                    for (const columnName of columnNamesOrAliases) {\n                        column = columns[(aliases[columnName] || columnName)];\n                        row.push(column ? column[i] : void 0);\n                    }\n                }\n                return rows;\n            }\n            /**\n             * Returns the unique version tag of the current state of the table.\n             *\n             * @function Highcharts.DataTable#getVersionTag\n             *\n             * @return {string}\n             * Unique version tag.\n             */\n            getVersionTag() {\n                return this.versionTag;\n            }\n            /**\n             * Checks for given column names or aliases.\n             *\n             * @function Highcharts.DataTable#hasColumns\n             *\n             * @param {Array<string>} columnNamesOrAliases\n             * Column names of aliases to check.\n             *\n             * @return {boolean}\n             * Returns `true` if all columns have been found, otherwise `false`.\n             */\n            hasColumns(columnNamesOrAliases) {\n                const table = this, aliases = table.aliases, columns = table.columns;\n                for (let i = 0, iEnd = columnNamesOrAliases.length, columnName; i < iEnd; ++i) {\n                    columnName = columnNamesOrAliases[i];\n                    if (!columns[columnName] && !aliases[columnName]) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * Searches for a specific cell value.\n             *\n             * @function Highcharts.DataTable#hasRowWith\n             *\n             * @param {string} columnNameOrAlias\n             * Column to search in.\n             *\n             * @param {Highcharts.DataTableCellType} cellValue\n             * Cell value to search for. `NaN` and `undefined` are not supported.\n             *\n             * @return {boolean}\n             * True, if a row has been found, otherwise false.\n             */\n            hasRowWith(columnNameOrAlias, cellValue) {\n                const table = this;\n                columnNameOrAlias = (table.aliases[columnNameOrAlias] ||\n                    columnNameOrAlias);\n                const column = table.columns[columnNameOrAlias];\n                if (column) {\n                    return (column.indexOf(cellValue) !== -1);\n                }\n                return false;\n            }\n            /**\n             * Registers a callback for a specific event.\n             *\n             * @function Highcharts.DataTable#on\n             *\n             * @param {string} type\n             * Event type as a string.\n             *\n             * @param {Highcharts.EventCallbackFunction<Highcharts.DataTable>} callback\n             * Function to register for an event callback.\n             *\n             * @return {Function}\n             * Function to unregister callback from the event.\n             */\n            on(type, callback) {\n                return addEvent(this, type, callback);\n            }\n            /**\n             * Renames a column of cell values.\n             *\n             * @function Highcharts.DataTable#renameColumn\n             *\n             * @param {string} columnName\n             * Name of the column to be renamed.\n             *\n             * @param {string} newColumnName\n             * New name of the column. An existing column with the same name will be\n             * replaced.\n             *\n             * @return {boolean}\n             * Returns `true` if successful, `false` if the column was not found.\n             */\n            renameColumn(columnName, newColumnName) {\n                const table = this, columns = table.columns;\n                if (columns[columnName]) {\n                    if (columnName !== newColumnName) {\n                        const aliases = table.aliases;\n                        if (aliases[newColumnName]) {\n                            delete aliases[newColumnName];\n                        }\n                        columns[newColumnName] = columns[columnName];\n                        delete columns[columnName];\n                        if (table.rowKeysId) {\n                            // Ensure that row keys column is last\n                            this.moveRowKeysColumnToLast(columns, table.rowKeysId);\n                        }\n                    }\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * Sets a cell value based on the row index and column name or alias.  Will\n             * insert a new column, if not found.\n             *\n             * @function Highcharts.DataTable#setCell\n             *\n             * @param {string} columnNameOrAlias\n             * Column name or alias to set.\n             *\n             * @param {number|undefined} rowIndex\n             * Row index to set.\n             *\n             * @param {Highcharts.DataTableCellType} cellValue\n             * Cell value to set.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits #setCell\n             * @emits #afterSetCell\n             */\n            setCell(columnNameOrAlias, rowIndex, cellValue, eventDetail) {\n                const table = this, columns = table.columns, modifier = table.modifier;\n                columnNameOrAlias = (table.aliases[columnNameOrAlias] ||\n                    columnNameOrAlias);\n                let column = columns[columnNameOrAlias];\n                if (column && column[rowIndex] === cellValue) {\n                    return;\n                }\n                table.emit({\n                    type: 'setCell',\n                    cellValue,\n                    columnName: columnNameOrAlias,\n                    detail: eventDetail,\n                    rowIndex\n                });\n                if (!column) {\n                    column = columns[columnNameOrAlias] = new Array(table.rowCount);\n                }\n                if (rowIndex >= table.rowCount) {\n                    table.rowCount = (rowIndex + 1);\n                }\n                column[rowIndex] = cellValue;\n                if (modifier) {\n                    modifier.modifyCell(table, columnNameOrAlias, rowIndex, cellValue);\n                }\n                table.emit({\n                    type: 'afterSetCell',\n                    cellValue,\n                    columnName: columnNameOrAlias,\n                    detail: eventDetail,\n                    rowIndex\n                });\n            }\n            /**\n             * Sets cell values for a column. Will insert a new column, if not found.\n             *\n             * @function Highcharts.DataTable#setColumn\n             *\n             * @param {string} columnNameOrAlias\n             * Column name or alias to set.\n             *\n             * @param {Highcharts.DataTableColumn} [column]\n             * Values to set in the column.\n             *\n             * @param {number} [rowIndex=0]\n             * Index of the first row to change. (Default: 0)\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits #setColumns\n             * @emits #afterSetColumns\n             */\n            setColumn(columnNameOrAlias, column = [], rowIndex = 0, eventDetail) {\n                this.setColumns({ [columnNameOrAlias]: column }, rowIndex, eventDetail);\n            }\n            /**\n             * Sets cell values for multiple columns. Will insert new columns, if not\n             * found.\n             *\n             * @function Highcharts.DataTable#setColumns\n             *\n             * @param {Highcharts.DataTableColumnCollection} columns\n             * Columns as a collection, where the keys are the column names or aliases.\n             *\n             * @param {number} [rowIndex]\n             * Index of the first row to change. Keep undefined to reset.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits #setColumns\n             * @emits #afterSetColumns\n             */\n            setColumns(columns, rowIndex, eventDetail) {\n                const table = this, tableColumns = table.columns, tableModifier = table.modifier, reset = (typeof rowIndex === 'undefined'), columnNames = Object.keys(columns);\n                table.emit({\n                    type: 'setColumns',\n                    columns,\n                    columnNames,\n                    detail: eventDetail,\n                    rowIndex\n                });\n                for (let i = 0, iEnd = columnNames.length, column, columnName; i < iEnd; ++i) {\n                    columnName = columnNames[i];\n                    column = columns[columnName];\n                    columnName = (table.aliases[columnName] ||\n                        columnName);\n                    if (reset) {\n                        tableColumns[columnName] = column.slice();\n                        table.rowCount = column.length;\n                    }\n                    else {\n                        const tableColumn = (tableColumns[columnName] ?\n                            tableColumns[columnName] :\n                            tableColumns[columnName] = new Array(table.rowCount));\n                        for (let i = (rowIndex || 0), iEnd = column.length; i < iEnd; ++i) {\n                            tableColumn[i] = column[i];\n                        }\n                        table.rowCount = Math.max(table.rowCount, tableColumn.length);\n                    }\n                }\n                const tableColumnNames = Object.keys(tableColumns);\n                for (let i = 0, iEnd = tableColumnNames.length; i < iEnd; ++i) {\n                    tableColumns[tableColumnNames[i]].length = table.rowCount;\n                }\n                if (tableModifier) {\n                    tableModifier.modifyColumns(table, columns, (rowIndex || 0));\n                }\n                if (table.rowKeysId) {\n                    // Ensure that the row keys column is always last\n                    this.moveRowKeysColumnToLast(tableColumns, table.rowKeysId);\n                }\n                table.emit({\n                    type: 'afterSetColumns',\n                    columns,\n                    columnNames,\n                    detail: eventDetail,\n                    rowIndex\n                });\n            }\n            /**\n             * Sets the row key column. This column is invisible and the cells\n             * serve as identifiers to the rows they are contained in. Accessing\n             * rows by keys instead of indexes is necessary in cases where rows\n             * are rearranged by a DataModifier (e.g. SortModifier or RangeModifier).\n             *\n             * @function Highcharts.DataTable#setRowKeysColumn\n             *\n             * @param {number} nRows\n             * Number of rows to add to the column.\n             *\n             */\n            setRowKeysColumn(nRows) {\n                const id = this.rowKeysId;\n                if (!id) {\n                    return;\n                }\n                this.columns[id] = [];\n                const keysArray = this.columns[id];\n                for (let i = 0; i < nRows; i++) {\n                    keysArray.push(id + '_' + i);\n                }\n            }\n            /**\n             * Get the row key column.\n             *\n             * @function Highcharts.DataTable#getRowKeysColumn\n             *     *\n             * @return {DataTable.Column|undefined}\n             * Returns row keys if rowKeysId is defined, else undefined.\n             */\n            getRowKeysColumn() {\n                const id = this.rowKeysId;\n                if (id) {\n                    return this.columns[id];\n                }\n            }\n            /**\n             * Get the row index in the original (unmodified) data table.\n             *\n             * @function Highcharts.DataTable#getRowIndexOriginal\n             *\n             * @param {number} idx\n             * Row index in the modified data table.\n             *\n             * @return {string}\n             * Row index in the original data table.\n             */\n            getRowIndexOriginal(idx) {\n                const id = this.rowKeysId;\n                if (id) {\n                    const rowKeyCol = this.columns[id];\n                    const idxOrig = '' + rowKeyCol[idx];\n                    return idxOrig.split('_')[1];\n                }\n                return String(idx);\n            }\n            /**\n             * Sets or unsets the modifier for the table.\n             *\n             * @param {Highcharts.DataModifier} [modifier]\n             * Modifier to set, or `undefined` to unset.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Promise<Highcharts.DataTable>}\n             * Resolves to this table if successful, or rejects on failure.\n             *\n             * @emits #setModifier\n             * @emits #afterSetModifier\n             */\n            setModifier(modifier, eventDetail) {\n                const table = this;\n                let promise;\n                table.emit({\n                    type: 'setModifier',\n                    detail: eventDetail,\n                    modifier,\n                    modified: table.modified\n                });\n                table.modified = table;\n                table.modifier = modifier;\n                if (modifier) {\n                    promise = modifier.modify(table);\n                }\n                else {\n                    promise = Promise.resolve(table);\n                }\n                return promise\n                    .then((table) => {\n                    table.emit({\n                        type: 'afterSetModifier',\n                        detail: eventDetail,\n                        modifier,\n                        modified: table.modified\n                    });\n                    return table;\n                })['catch']((error) => {\n                    table.emit({\n                        type: 'setModifierError',\n                        error,\n                        modifier,\n                        modified: table.modified\n                    });\n                    throw error;\n                });\n            }\n            /**\n             * Sets cell values of a row. Will insert a new row, if no index was\n             * provided, or if the index is higher than the total number of table rows.\n             *\n             * Note: This function is just a simplified wrap of\n             * {@link Highcharts.DataTable#setRows}.\n             *\n             * @function Highcharts.DataTable#setRow\n             *\n             * @param {Highcharts.DataTableRow|Highcharts.DataTableRowObject} row\n             * Cell values to set.\n             *\n             * @param {number} [rowIndex]\n             * Index of the row to set. Leave `undefind` to add as a new row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits #setRows\n             * @emits #afterSetRows\n             */\n            setRow(row, rowIndex, eventDetail) {\n                this.setRows([row], rowIndex, eventDetail);\n            }\n            /**\n             * Sets cell values for multiple rows. Will insert new rows, if no index was\n             * was provided, or if the index is higher than the total number of table\n             * rows.\n             *\n             * @function Highcharts.DataTable#setRows\n             *\n             * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n             * Row values to set.\n             *\n             * @param {number} [rowIndex]\n             * Index of the first row to set. Leave `undefined` to add as new rows.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits #setRows\n             * @emits #afterSetRows\n             */\n            setRows(rows, rowIndex = this.rowCount, eventDetail) {\n                const table = this, aliases = table.aliases, columns = table.columns, columnNames = Object.keys(columns), modifier = table.modifier, rowCount = rows.length;\n                table.emit({\n                    type: 'setRows',\n                    detail: eventDetail,\n                    rowCount,\n                    rowIndex,\n                    rows\n                });\n                for (let i = 0, i2 = rowIndex, row; i < rowCount; ++i, ++i2) {\n                    row = rows[i];\n                    if (row === DataTable.NULL) {\n                        for (let j = 0, jEnd = columnNames.length; j < jEnd; ++j) {\n                            columns[columnNames[j]][i2] = null;\n                        }\n                    }\n                    else if (row instanceof Array) {\n                        for (let j = 0, jEnd = columnNames.length; j < jEnd; ++j) {\n                            columns[columnNames[j]][i2] = row[j];\n                        }\n                    }\n                    else {\n                        const rowColumnNames = Object.keys(row);\n                        for (let j = 0, jEnd = rowColumnNames.length, rowColumnName; j < jEnd; ++j) {\n                            rowColumnName = rowColumnNames[j];\n                            rowColumnName = (aliases[rowColumnName] || rowColumnName);\n                            if (!columns[rowColumnName]) {\n                                columns[rowColumnName] = new Array(i2 + 1);\n                            }\n                            columns[rowColumnName][i2] = row[rowColumnName];\n                        }\n                    }\n                }\n                const indexRowCount = (rowIndex + rowCount);\n                if (indexRowCount > table.rowCount) {\n                    table.rowCount = indexRowCount;\n                    for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                        columns[columnNames[i]].length = indexRowCount;\n                    }\n                }\n                if (this.rowKeysId && !columnNames.includes(this.rowKeysId)) {\n                    this.setRowKeysColumn(rowCount);\n                }\n                if (modifier) {\n                    modifier.modifyRows(table, rows, rowIndex);\n                }\n                table.emit({\n                    type: 'afterSetRows',\n                    detail: eventDetail,\n                    rowCount,\n                    rowIndex,\n                    rows\n                });\n            }\n            // The row keys column must always be the last column\n            moveRowKeysColumnToLast(columns, id) {\n                const rowKeyColumn = columns[id];\n                delete columns[id];\n                columns[id] = rowKeyColumn;\n            }\n            // The row keys column must be removed in some methods\n            // (API backwards compatibility)\n            removeRowKeysColumn(columnNamesOrAliases) {\n                if (this.rowKeysId) {\n                    const pos = columnNamesOrAliases.indexOf(this.rowKeysId);\n                    if (pos !== -1) {\n                        // Always the last column\n                        columnNamesOrAliases.pop();\n                    }\n                }\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Null state for a row record. In some cases, a row in a table may not\n         * contain any data or may be invalid. In these cases, a null state can be\n         * used to indicate that the row record is empty or invalid.\n         *\n         * @name Highcharts.DataTable.NULL\n         * @type {Highcharts.DataTableRowObject}\n         *\n         * @see {@link Highcharts.DataTable.isNull} for a null test.\n         *\n         * @example\n         * table.setRows([DataTable.NULL, DataTable.NULL], 10);\n         */\n        DataTable.NULL = {};\n        /**\n         * Semantic version string of the DataTable class.\n         * @internal\n         */\n        DataTable.version = '1.0.0';\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return DataTable;\n    });\n    _registerModule(_modules, 'Data/Connectors/DataConnector.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Data/DataTable.js'], _modules['Core/Utilities.js']], function (DataModifier, DataTable, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *  - Wojciech Chmiel\n         *  - GÃ¸ran Slettemark\n         *\n         * */\n        const { addEvent, fireEvent, merge, pick } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Abstract class providing an interface for managing a DataConnector.\n         *\n         * @private\n         */\n        class DataConnector {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructor for the connector class.\n             *\n             * @param {DataConnector.UserOptions} [options]\n             * Options to use in the connector.\n             */\n            constructor(options = {}) {\n                this.table = new DataTable(options.dataTable);\n                this.metadata = options.metadata || { columns: {} };\n            }\n            /**\n             * Poll timer ID, if active.\n             */\n            get polling() {\n                return !!this.polling;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Method for adding metadata for a single column.\n             *\n             * @param {string} name\n             * The name of the column to be described.\n             *\n             * @param {DataConnector.MetaColumn} columnMeta\n             * The metadata to apply to the column.\n             */\n            describeColumn(name, columnMeta) {\n                const connector = this, columns = connector.metadata.columns;\n                columns[name] = merge(columns[name] || {}, columnMeta);\n            }\n            /**\n             * Method for applying columns meta information to the whole DataConnector.\n             *\n             * @param {Highcharts.Dictionary<DataConnector.MetaColumn>} columns\n             * Pairs of column names and MetaColumn objects.\n             */\n            describeColumns(columns) {\n                const connector = this, columnNames = Object.keys(columns);\n                let columnName;\n                while (typeof (columnName = columnNames.pop()) === 'string') {\n                    connector.describeColumn(columnName, columns[columnName]);\n                }\n            }\n            /**\n             * Emits an event on the connector to all registered callbacks of this\n             * event.\n             *\n             * @param {DataConnector.Event} [e]\n             * Event object containing additional event information.\n             */\n            emit(e) {\n                fireEvent(this, e.type, e);\n            }\n            /**\n             * Returns the order of columns.\n             *\n             * @param {boolean} [usePresentationState]\n             * Whether to use the column order of the presentation state of the table.\n             *\n             * @return {Array<string>|undefined}\n             * Order of columns.\n             */\n            getColumnOrder(\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            usePresentationState) {\n                const connector = this, columns = connector.metadata.columns, names = Object.keys(columns || {});\n                if (names.length) {\n                    return names.sort((a, b) => (pick(columns[a].index, 0) - pick(columns[b].index, 0)));\n                }\n            }\n            /**\n             * Retrieves the columns of the dataTable,\n             * applies column order from meta.\n             *\n             * @param {boolean} [usePresentationOrder]\n             * Whether to use the column order of the presentation state of the table.\n             *\n             * @return {Highcharts.DataTableColumnCollection}\n             * An object with the properties `columnNames` and `columnValues`\n             */\n            getSortedColumns(usePresentationOrder) {\n                return this.table.getColumns(this.getColumnOrder(usePresentationOrder));\n            }\n            /**\n             * The default load method, which fires the `afterLoad` event\n             *\n             * @return {Promise<DataConnector>}\n             * The loaded connector.\n             *\n             * @emits DataConnector#afterLoad\n             */\n            load() {\n                fireEvent(this, 'afterLoad', { table: this.table });\n                return Promise.resolve(this);\n            }\n            /**\n             * Registers a callback for a specific connector event.\n             *\n             * @param {string} type\n             * Event type as a string.\n             *\n             * @param {DataEventEmitter.Callback} callback\n             * Function to register for the connector callback.\n             *\n             * @return {Function}\n             * Function to unregister callback from the connector event.\n             */\n            on(type, callback) {\n                return addEvent(this, type, callback);\n            }\n            /**\n             * The default save method, which fires the `afterSave` event.\n             *\n             * @return {Promise<DataConnector>}\n             * The saved connector.\n             *\n             * @emits DataConnector#afterSave\n             * @emits DataConnector#saveError\n             */\n            save() {\n                fireEvent(this, 'saveError', { table: this.table });\n                return Promise.reject(new Error('Not implemented'));\n            }\n            /**\n             * Sets the index and order of columns.\n             *\n             * @param {Array<string>} columnNames\n             * Order of columns.\n             */\n            setColumnOrder(columnNames) {\n                const connector = this;\n                for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                    connector.describeColumn(columnNames[i], { index: i });\n                }\n            }\n            setModifierOptions(modifierOptions) {\n                const ModifierClass = (modifierOptions &&\n                    DataModifier.types[modifierOptions.type]);\n                return this.table\n                    .setModifier(ModifierClass ?\n                    new ModifierClass(modifierOptions) :\n                    void 0)\n                    .then(() => this);\n            }\n            /**\n             * Starts polling new data after the specific time span in milliseconds.\n             *\n             * @param {number} refreshTime\n             * Refresh time in milliseconds between polls.\n             */\n            startPolling(refreshTime = 1000) {\n                const connector = this;\n                window.clearTimeout(connector._polling);\n                connector._polling = window.setTimeout(() => connector\n                    .load()['catch']((error) => connector.emit({\n                    type: 'loadError',\n                    error,\n                    table: connector.table\n                }))\n                    .then(() => {\n                    if (connector._polling) {\n                        connector.startPolling(refreshTime);\n                    }\n                }), refreshTime);\n            }\n            /**\n             * Stops polling data.\n             */\n            stopPolling() {\n                const connector = this;\n                window.clearTimeout(connector._polling);\n                delete connector._polling;\n            }\n            /**\n             * Retrieves metadata from a single column.\n             *\n             * @param {string} name\n             * The identifier for the column that should be described\n             *\n             * @return {DataConnector.MetaColumn|undefined}\n             * Returns a MetaColumn object if found.\n             */\n            whatIs(name) {\n                return this.metadata.columns[name];\n            }\n        }\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (DataConnector) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            /**\n             * Registry as a record object with connector names and their class.\n             */\n            DataConnector.types = {};\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Adds a connector class to the registry. The connector has to provide the\n             * `DataConnector.options` property and the `DataConnector.load` method to\n             * modify the table.\n             *\n             * @private\n             *\n             * @param {string} key\n             * Registry key of the connector class.\n             *\n             * @param {DataConnectorType} DataConnectorClass\n             * Connector class (aka class constructor) to register.\n             *\n             * @return {boolean}\n             * Returns true, if the registration was successful. False is returned, if\n             * their is already a connector registered with this key.\n             */\n            function registerType(key, DataConnectorClass) {\n                return (!!key &&\n                    !DataConnector.types[key] &&\n                    !!(DataConnector.types[key] = DataConnectorClass));\n            }\n            DataConnector.registerType = registerType;\n        })(DataConnector || (DataConnector = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return DataConnector;\n    });\n    _registerModule(_modules, 'Data/Converters/DataConverter.js', [_modules['Data/DataTable.js'], _modules['Core/Utilities.js']], function (DataTable, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *  - Sebastian Bochan\n         *  - GÃ¸ran Slettemark\n         *  - Torstein HÃ¸nsi\n         *  - Wojciech Chmiel\n         *\n         * */\n        const { addEvent, fireEvent, isNumber, merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Base class providing an interface and basic methods for a DataConverter\n         *\n         * @private\n         */\n        class DataConverter {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the DataConverter.\n             *\n             * @param {DataConverter.UserOptions} [options]\n             * Options for the DataConverter.\n             */\n            constructor(options) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                /**\n                 * A collection of available date formats.\n                 */\n                this.dateFormats = {\n                    'YYYY/mm/dd': {\n                        regex: /^(\\d{4})([\\-\\.\\/])(\\d{1,2})\\2(\\d{1,2})$/,\n                        parser: function (match) {\n                            return (match ?\n                                Date.UTC(+match[1], match[3] - 1, +match[4]) :\n                                NaN);\n                        }\n                    },\n                    'dd/mm/YYYY': {\n                        regex: /^(\\d{1,2})([\\-\\.\\/])(\\d{1,2})\\2(\\d{4})$/,\n                        parser: function (match) {\n                            return (match ?\n                                Date.UTC(+match[4], match[3] - 1, +match[1]) :\n                                NaN);\n                        },\n                        alternative: 'mm/dd/YYYY' // Different format with the same regex\n                    },\n                    'mm/dd/YYYY': {\n                        regex: /^(\\d{1,2})([\\-\\.\\/])(\\d{1,2})\\2(\\d{4})$/,\n                        parser: function (match) {\n                            return (match ?\n                                Date.UTC(+match[4], match[1] - 1, +match[3]) :\n                                NaN);\n                        }\n                    },\n                    'dd/mm/YY': {\n                        regex: /^(\\d{1,2})([\\-\\.\\/])(\\d{1,2})\\2(\\d{2})$/,\n                        parser: function (match) {\n                            const d = new Date();\n                            if (!match) {\n                                return NaN;\n                            }\n                            let year = +match[4];\n                            if (year > (d.getFullYear() - 2000)) {\n                                year += 1900;\n                            }\n                            else {\n                                year += 2000;\n                            }\n                            return Date.UTC(year, match[3] - 1, +match[1]);\n                        },\n                        alternative: 'mm/dd/YY' // Different format with the same regex\n                    },\n                    'mm/dd/YY': {\n                        regex: /^(\\d{1,2})([\\-\\.\\/])(\\d{1,2})\\2(\\d{2})$/,\n                        parser: function (match) {\n                            return (match ?\n                                Date.UTC(+match[4] + 2000, match[1] - 1, +match[3]) :\n                                NaN);\n                        }\n                    }\n                };\n                const mergedOptions = merge(DataConverter.defaultOptions, options);\n                let regExpPoint = mergedOptions.decimalPoint;\n                if (regExpPoint === '.' || regExpPoint === ',') {\n                    regExpPoint = regExpPoint === '.' ? '\\\\.' : ',';\n                    this.decimalRegExp =\n                        new RegExp('^(-?[0-9]+)' + regExpPoint + '([0-9]+)$');\n                }\n                this.options = mergedOptions;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Converts a value to a boolean.\n             *\n             * @param {DataConverter.Type} value\n             * Value to convert.\n             *\n             * @return {boolean}\n             * Converted value as a boolean.\n             */\n            asBoolean(value) {\n                if (typeof value === 'boolean') {\n                    return value;\n                }\n                if (typeof value === 'string') {\n                    return value !== '' && value !== '0' && value !== 'false';\n                }\n                return !!this.asNumber(value);\n            }\n            /**\n             * Converts a value to a Date.\n             *\n             * @param {DataConverter.Type} value\n             * Value to convert.\n             *\n             * @return {globalThis.Date}\n             * Converted value as a Date.\n             */\n            asDate(value) {\n                let timestamp;\n                if (typeof value === 'string') {\n                    timestamp = this.parseDate(value);\n                }\n                else if (typeof value === 'number') {\n                    timestamp = value;\n                }\n                else if (value instanceof Date) {\n                    return value;\n                }\n                else {\n                    timestamp = this.parseDate(this.asString(value));\n                }\n                return new Date(timestamp);\n            }\n            /**\n             * Casts a string value to it's guessed type\n             *\n             * @param {*} value\n             * The value to examine.\n             *\n             * @return {number|string|Date}\n             * The converted value.\n             */\n            asGuessedType(value) {\n                const converter = this, typeMap = {\n                    'number': converter.asNumber,\n                    'Date': converter.asDate,\n                    'string': converter.asString\n                };\n                return typeMap[converter.guessType(value)].call(converter, value);\n            }\n            /**\n             * Converts a value to a number.\n             *\n             * @param {DataConverter.Type} value\n             * Value to convert.\n             *\n             * @return {number}\n             * Converted value as a number.\n             */\n            asNumber(value) {\n                if (typeof value === 'number') {\n                    return value;\n                }\n                if (typeof value === 'boolean') {\n                    return value ? 1 : 0;\n                }\n                if (typeof value === 'string') {\n                    const decimalRegex = this.decimalRegExp;\n                    if (value.indexOf(' ') > -1) {\n                        value = value.replace(/\\s+/g, '');\n                    }\n                    if (decimalRegex) {\n                        if (!decimalRegex.test(value)) {\n                            return NaN;\n                        }\n                        value = value.replace(decimalRegex, '$1.$2');\n                    }\n                    return parseFloat(value);\n                }\n                if (value instanceof Date) {\n                    return value.getDate();\n                }\n                if (value) {\n                    return value.getRowCount();\n                }\n                return NaN;\n            }\n            /**\n             * Converts a value to a string.\n             *\n             * @param {DataConverter.Type} value\n             * Value to convert.\n             *\n             * @return {string}\n             * Converted value as a string.\n             */\n            asString(value) {\n                return '' + value;\n            }\n            /**\n             * Tries to guess the date format\n             *  - Check if either month candidate exceeds 12\n             *  - Check if year is missing (use current year)\n             *  - Check if a shortened year format is used (e.g. 1/1/99)\n             *  - If no guess can be made, the user must be prompted\n             * data is the data to deduce a format based on\n             * @private\n             *\n             * @param {Array<string>} data\n             * Data to check the format.\n             *\n             * @param {number} limit\n             * Max data to check the format.\n             *\n             * @param {boolean} save\n             * Whether to save the date format in the converter options.\n             */\n            deduceDateFormat(data, limit, save) {\n                const parser = this, stable = [], max = [];\n                let format = 'YYYY/mm/dd', thing, guessedFormat = [], i = 0, madeDeduction = false, \n                /// candidates = {},\n                elem, j;\n                if (!limit || limit > data.length) {\n                    limit = data.length;\n                }\n                for (; i < limit; i++) {\n                    if (typeof data[i] !== 'undefined' &&\n                        data[i] && data[i].length) {\n                        thing = data[i]\n                            .trim()\n                            .replace(/[\\-\\.\\/]/g, ' ')\n                            .split(' ');\n                        guessedFormat = [\n                            '',\n                            '',\n                            ''\n                        ];\n                        for (j = 0; j < thing.length; j++) {\n                            if (j < guessedFormat.length) {\n                                elem = parseInt(thing[j], 10);\n                                if (elem) {\n                                    max[j] = (!max[j] || max[j] < elem) ? elem : max[j];\n                                    if (typeof stable[j] !== 'undefined') {\n                                        if (stable[j] !== elem) {\n                                            stable[j] = false;\n                                        }\n                                    }\n                                    else {\n                                        stable[j] = elem;\n                                    }\n                                    if (elem > 31) {\n                                        if (elem < 100) {\n                                            guessedFormat[j] = 'YY';\n                                        }\n                                        else {\n                                            guessedFormat[j] = 'YYYY';\n                                        }\n                                        /// madeDeduction = true;\n                                    }\n                                    else if (elem > 12 &&\n                                        elem <= 31) {\n                                        guessedFormat[j] = 'dd';\n                                        madeDeduction = true;\n                                    }\n                                    else if (!guessedFormat[j].length) {\n                                        guessedFormat[j] = 'mm';\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (madeDeduction) {\n                    // This handles a few edge cases with hard to guess dates\n                    for (j = 0; j < stable.length; j++) {\n                        if (stable[j] !== false) {\n                            if (max[j] > 12 &&\n                                guessedFormat[j] !== 'YY' &&\n                                guessedFormat[j] !== 'YYYY') {\n                                guessedFormat[j] = 'YY';\n                            }\n                        }\n                        else if (max[j] > 12 && guessedFormat[j] === 'mm') {\n                            guessedFormat[j] = 'dd';\n                        }\n                    }\n                    // If the middle one is dd, and the last one is dd,\n                    // the last should likely be year.\n                    if (guessedFormat.length === 3 &&\n                        guessedFormat[1] === 'dd' &&\n                        guessedFormat[2] === 'dd') {\n                        guessedFormat[2] = 'YY';\n                    }\n                    format = guessedFormat.join('/');\n                    // If the caculated format is not valid, we need to present an\n                    // error.\n                }\n                // Save the deduced format in the converter options.\n                if (save) {\n                    parser.options.dateFormat = format;\n                }\n                return format;\n            }\n            /**\n             * Emits an event on the DataConverter instance.\n             *\n             * @param {DataConverter.Event} [e]\n             * Event object containing additional event data\n             */\n            emit(e) {\n                fireEvent(this, e.type, e);\n            }\n            /**\n             * Initiates the data exporting. Should emit `exportError` on failure.\n             *\n             * @param {DataConnector} connector\n             * Connector to export from.\n             *\n             * @param {DataConverter.Options} [options]\n             * Options for the export.\n             */\n            export(\n            /* eslint-disable @typescript-eslint/no-unused-vars */\n            connector, options\n            /* eslint-enable @typescript-eslint/no-unused-vars */\n            ) {\n                this.emit({\n                    type: 'exportError',\n                    columns: [],\n                    headers: []\n                });\n                throw new Error('Not implemented');\n            }\n            /**\n             * Getter for the data table.\n             *\n             * @return {DataTable}\n             * Table of parsed data.\n             */\n            getTable() {\n                throw new Error('Not implemented');\n            }\n            /**\n             * Guesses the potential type of a string value for parsing CSV etc.\n             *\n             * @param {*} value\n             * The value to examine.\n             *\n             * @return {'number'|'string'|'Date'}\n             * Type string, either `string`, `Date`, or `number`.\n             */\n            guessType(value) {\n                const converter = this;\n                let result = 'string';\n                if (typeof value === 'string') {\n                    const trimedValue = converter.trim(`${value}`), decimalRegExp = converter.decimalRegExp;\n                    let innerTrimedValue = converter.trim(trimedValue, true);\n                    if (decimalRegExp) {\n                        innerTrimedValue = (decimalRegExp.test(innerTrimedValue) ?\n                            innerTrimedValue.replace(decimalRegExp, '$1.$2') :\n                            '');\n                    }\n                    const floatValue = parseFloat(innerTrimedValue);\n                    if (+innerTrimedValue === floatValue) {\n                        // String is numeric\n                        value = floatValue;\n                    }\n                    else {\n                        // Determine if a date string\n                        const dateValue = converter.parseDate(value);\n                        result = isNumber(dateValue) ? 'Date' : 'string';\n                    }\n                }\n                if (typeof value === 'number') {\n                    // Greater than milliseconds in a year assumed timestamp\n                    result = value > 365 * 24 * 3600 * 1000 ? 'Date' : 'number';\n                }\n                return result;\n            }\n            /**\n             * Registers a callback for a specific event.\n             *\n             * @param {string} type\n             * Event type as a string.\n             *\n             * @param {DataEventEmitter.Callback} callback\n             * Function to register for an modifier callback.\n             *\n             * @return {Function}\n             * Function to unregister callback from the modifier event.\n             */\n            on(type, callback) {\n                return addEvent(this, type, callback);\n            }\n            /**\n             * Initiates the data parsing. Should emit `parseError` on failure.\n             *\n             * @param {DataConverter.UserOptions} options\n             * Options of the DataConverter.\n             */\n            parse(\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            options) {\n                this.emit({\n                    type: 'parseError',\n                    columns: [],\n                    headers: []\n                });\n                throw new Error('Not implemented');\n            }\n            /**\n             * Parse a date and return it as a number.\n             *\n             * @function Highcharts.Data#parseDate\n             *\n             * @param {string} value\n             * Value to parse.\n             *\n             * @param {string} dateFormatProp\n             * Which of the predefined date formats\n             * to use to parse date values.\n             */\n            parseDate(value, dateFormatProp) {\n                const converter = this, options = converter.options;\n                let dateFormat = dateFormatProp || options.dateFormat, result = NaN, key, format, match;\n                if (options.parseDate) {\n                    result = options.parseDate(value);\n                }\n                else {\n                    // Auto-detect the date format the first time\n                    if (!dateFormat) {\n                        for (key in converter.dateFormats) { // eslint-disable-line guard-for-in\n                            format = converter.dateFormats[key];\n                            match = value.match(format.regex);\n                            if (match) {\n                                // `converter.options.dateFormat` = dateFormat = key;\n                                dateFormat = key;\n                                // `converter.options.alternativeFormat` =\n                                // format.alternative || '';\n                                result = format.parser(match);\n                                break;\n                            }\n                        }\n                        // Next time, use the one previously found\n                    }\n                    else {\n                        format = converter.dateFormats[dateFormat];\n                        if (!format) {\n                            // The selected format is invalid\n                            format = converter.dateFormats['YYYY/mm/dd'];\n                        }\n                        match = value.match(format.regex);\n                        if (match) {\n                            result = format.parser(match);\n                        }\n                    }\n                    // Fall back to Date.parse\n                    if (!match) {\n                        match = Date.parse(value);\n                        // External tools like Date.js and MooTools extend Date object\n                        // and returns a date.\n                        if (typeof match === 'object' &&\n                            match !== null &&\n                            match.getTime) {\n                            result = (match.getTime() -\n                                match.getTimezoneOffset() *\n                                    60000);\n                            // Timestamp\n                        }\n                        else if (isNumber(match)) {\n                            result = match - (new Date(match)).getTimezoneOffset() * 60000;\n                            if ( // Reset dates without year in Chrome\n                            value.indexOf('2001') === -1 &&\n                                (new Date(result)).getFullYear() === 2001) {\n                                result = NaN;\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            /**\n             * Trim a string from whitespaces.\n             *\n             * @param {string} str\n             * String to trim.\n             *\n             * @param {boolean} [inside=false]\n             * Remove all spaces between numbers.\n             *\n             * @return {string}\n             * Trimed string\n             */\n            trim(str, inside) {\n                if (typeof str === 'string') {\n                    str = str.replace(/^\\s+|\\s+$/g, '');\n                    // Clear white space insdie the string, like thousands separators\n                    if (inside && /^[\\d\\s]+$/.test(str)) {\n                        str = str.replace(/\\s/g, '');\n                    }\n                }\n                return str;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options\n         */\n        DataConverter.defaultOptions = {\n            dateFormat: '',\n            alternativeFormat: '',\n            startColumn: 0,\n            endColumn: Number.MAX_VALUE,\n            startRow: 0,\n            endRow: Number.MAX_VALUE,\n            firstRowAsNames: true,\n            switchRowsAndColumns: false\n        };\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        /**\n         * Additionally provided types for events and conversion.\n         */\n        (function (DataConverter) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Converts an array of columns to a table instance. Second dimension of the\n             * array are the row cells.\n             *\n             * @param {Array<DataTable.Column>} [columns]\n             * Array to convert.\n             *\n             * @param {Array<string>} [headers]\n             * Column names to use.\n             *\n             * @return {DataTable}\n             * Table instance from the arrays.\n             */\n            function getTableFromColumns(columns = [], headers = []) {\n                const table = new DataTable();\n                for (let i = 0, iEnd = Math.max(headers.length, columns.length); i < iEnd; ++i) {\n                    table.setColumn(headers[i] || `${i}`, columns[i]);\n                }\n                return table;\n            }\n            DataConverter.getTableFromColumns = getTableFromColumns;\n        })(DataConverter || (DataConverter = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return DataConverter;\n    });\n    _registerModule(_modules, 'Data/DataCursor.js', [], function () {\n        /* *\n         *\n         *  (c) 2020-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * This class manages state cursors pointing on {@link Data.DataTable}. It\n         * creates a relation between states of the user interface and the table cells,\n         * columns, or rows.\n         *\n         * @class\n         * @name Data.DataCursor\n         */\n        class DataCursor {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(stateMap = {}) {\n                this.emittingRegister = [];\n                this.listenerMap = {};\n                this.stateMap = stateMap;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * This function registers a listener for a specific state and table.\n             *\n             * @example\n             * ```TypeScript\n             * dataCursor.addListener(myTable.id, 'hover', (e: DataCursor.Event) => {\n             *     if (e.cursor.type === 'position') {\n             *         console.log(`Hover over row #${e.cursor.row}.`);\n             *     }\n             * });\n             * ```\n             *\n             * @function #addListener\n             *\n             * @param {Data.DataCursor.TableId} tableId\n             * The ID of the table to listen to.\n             *\n             * @param {Data.DataCursor.State} state\n             * The state on the table to listen to.\n             *\n             * @param {Data.DataCursor.Listener} listener\n             * The listener to register.\n             *\n             * @return {Data.DataCursor}\n             * Returns the DataCursor instance for a call chain.\n             */\n            addListener(tableId, state, listener) {\n                const listenerMap = this.listenerMap[tableId] = (this.listenerMap[tableId] ||\n                    {});\n                const listeners = listenerMap[state] = (listenerMap[state] ||\n                    []);\n                listeners.push(listener);\n                return this;\n            }\n            /**\n             * @private\n             */\n            buildEmittingTag(e) {\n                return (e.cursor.type === 'position' ?\n                    [\n                        e.table.id,\n                        e.cursor.column,\n                        e.cursor.row,\n                        e.cursor.state,\n                        e.cursor.type\n                    ] :\n                    [\n                        e.table.id,\n                        e.cursor.columns,\n                        e.cursor.firstRow,\n                        e.cursor.lastRow,\n                        e.cursor.state,\n                        e.cursor.type\n                    ]).join('\\0');\n            }\n            /**\n             * This function emits a state cursor related to a table. It will provide\n             * lasting state cursors of the table to listeners.\n             *\n             * @example\n             * ```ts\n             * dataCursor.emit(myTable, {\n             *     type: 'position',\n             *     column: 'city',\n             *     row: 4,\n             *     state: 'hover',\n             * });\n             * ```\n             *\n             * @param {Data.DataTable} table\n             * The related table of the cursor.\n             *\n             * @param {Data.DataCursor.Type} cursor\n             * The state cursor to emit.\n             *\n             * @param {Event} [event]\n             * Optional event information from a related source.\n             *\n             * @param {boolean} [lasting]\n             * Whether this state cursor should be kept until it is cleared with\n             * {@link DataCursor#remitCursor}.\n             *\n             * @return {Data.DataCursor}\n             * Returns the DataCursor instance for a call chain.\n             */\n            emitCursor(table, cursor, event, lasting) {\n                const tableId = table.id, state = cursor.state, listeners = (this.listenerMap[tableId] &&\n                    this.listenerMap[tableId][state]);\n                if (listeners) {\n                    const stateMap = this.stateMap[tableId] = (this.stateMap[tableId] ?? {});\n                    const cursors = stateMap[cursor.state] || [];\n                    if (lasting) {\n                        if (!cursors.length) {\n                            stateMap[cursor.state] = cursors;\n                        }\n                        if (DataCursor.getIndex(cursor, cursors) === -1) {\n                            cursors.push(cursor);\n                        }\n                    }\n                    const e = {\n                        cursor,\n                        cursors,\n                        table\n                    };\n                    if (event) {\n                        e.event = event;\n                    }\n                    const emittingRegister = this.emittingRegister, emittingTag = this.buildEmittingTag(e);\n                    if (emittingRegister.indexOf(emittingTag) >= 0) {\n                        // Break call stack loops\n                        return this;\n                    }\n                    try {\n                        this.emittingRegister.push(emittingTag);\n                        for (let i = 0, iEnd = listeners.length; i < iEnd; ++i) {\n                            listeners[i].call(this, e);\n                        }\n                    }\n                    finally {\n                        const index = this.emittingRegister.indexOf(emittingTag);\n                        if (index >= 0) {\n                            this.emittingRegister.splice(index, 1);\n                        }\n                    }\n                }\n                return this;\n            }\n            /**\n             * Removes a lasting state cursor.\n             *\n             * @function #remitCursor\n             *\n             * @param {string} tableId\n             * ID of the related cursor table.\n             *\n             * @param {Data.DataCursor.Type} cursor\n             * Copy or reference of the cursor.\n             *\n             * @return {Data.DataCursor}\n             * Returns the DataCursor instance for a call chain.\n             */\n            remitCursor(tableId, cursor) {\n                const cursors = (this.stateMap[tableId] &&\n                    this.stateMap[tableId][cursor.state]);\n                if (cursors) {\n                    const index = DataCursor.getIndex(cursor, cursors);\n                    if (index >= 0) {\n                        cursors.splice(index, 1);\n                    }\n                }\n                return this;\n            }\n            /**\n             * This function removes a listener.\n             *\n             * @function #addListener\n             *\n             * @param {Data.DataCursor.TableId} tableId\n             * The ID of the table the listener is connected to.\n             *\n             * @param {Data.DataCursor.State} state\n             * The state on the table the listener is listening to.\n             *\n             * @param {Data.DataCursor.Listener} listener\n             * The listener to deregister.\n             *\n             * @return {Data.DataCursor}\n             * Returns the DataCursor instance for a call chain.\n             */\n            removeListener(tableId, state, listener) {\n                const listeners = (this.listenerMap[tableId] &&\n                    this.listenerMap[tableId][state]);\n                if (listeners) {\n                    const index = listeners.indexOf(listener);\n                    if (index >= 0) {\n                        listeners.splice(index, 1);\n                    }\n                }\n                return this;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Semantic version string of the DataCursor class.\n         * @internal\n         */\n        DataCursor.version = '1.0.0';\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        /**\n         * @class Data.DataCursor\n         */\n        (function (DataCursor) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Finds the index of an cursor in an array.\n             * @private\n             */\n            function getIndex(needle, cursors) {\n                if (needle.type === 'position') {\n                    for (let cursor, i = 0, iEnd = cursors.length; i < iEnd; ++i) {\n                        cursor = cursors[i];\n                        if (cursor.type === 'position' &&\n                            cursor.state === needle.state &&\n                            cursor.column === needle.column &&\n                            cursor.row === needle.row) {\n                            return i;\n                        }\n                    }\n                }\n                else {\n                    const columnNeedle = JSON.stringify(needle.columns);\n                    for (let cursor, i = 0, iEnd = cursors.length; i < iEnd; ++i) {\n                        cursor = cursors[i];\n                        if (cursor.type === 'range' &&\n                            cursor.state === needle.state &&\n                            cursor.firstRow === needle.firstRow &&\n                            cursor.lastRow === needle.lastRow &&\n                            JSON.stringify(cursor.columns) === columnNeedle) {\n                            return i;\n                        }\n                    }\n                }\n                return -1;\n            }\n            DataCursor.getIndex = getIndex;\n            /**\n             * Checks whether two cursor share the same properties.\n             * @private\n             */\n            function isEqual(cursorA, cursorB) {\n                if (cursorA.type === 'position' && cursorB.type === 'position') {\n                    return (cursorA.column === cursorB.column &&\n                        cursorA.row === cursorB.row &&\n                        cursorA.state === cursorB.state);\n                }\n                if (cursorA.type === 'range' && cursorB.type === 'range') {\n                    return (cursorA.firstRow === cursorB.firstRow &&\n                        cursorA.lastRow === cursorB.lastRow &&\n                        (JSON.stringify(cursorA.columns) ===\n                            JSON.stringify(cursorB.columns)));\n                }\n                return false;\n            }\n            DataCursor.isEqual = isEqual;\n            /**\n             * Checks whether a cursor is in a range.\n             * @private\n             */\n            function isInRange(needle, range) {\n                if (range.type === 'position') {\n                    range = toRange(range);\n                }\n                if (needle.type === 'position') {\n                    needle = toRange(needle, range);\n                }\n                const needleColumns = needle.columns;\n                const rangeColumns = range.columns;\n                return (needle.firstRow >= range.firstRow &&\n                    needle.lastRow <= range.lastRow &&\n                    (!needleColumns ||\n                        !rangeColumns ||\n                        needleColumns.every((column) => rangeColumns.indexOf(column) >= 0)));\n            }\n            DataCursor.isInRange = isInRange;\n            /**\n             * @private\n             */\n            function toPositions(cursor) {\n                if (cursor.type === 'position') {\n                    return [cursor];\n                }\n                const columns = (cursor.columns || []);\n                const positions = [];\n                const state = cursor.state;\n                for (let row = cursor.firstRow, rowEnd = cursor.lastRow; row < rowEnd; ++row) {\n                    if (!columns.length) {\n                        positions.push({\n                            type: 'position',\n                            row,\n                            state\n                        });\n                        continue;\n                    }\n                    for (let column = 0, columnEnd = columns.length; column < columnEnd; ++column) {\n                        positions.push({\n                            type: 'position',\n                            column: columns[column],\n                            row,\n                            state\n                        });\n                    }\n                }\n                return positions;\n            }\n            DataCursor.toPositions = toPositions;\n            /**\n             * @private\n             */\n            function toRange(cursor, defaultRange) {\n                if (cursor.type === 'range') {\n                    return cursor;\n                }\n                const range = {\n                    type: 'range',\n                    firstRow: (cursor.row ??\n                        (defaultRange && defaultRange.firstRow) ??\n                        0),\n                    lastRow: (cursor.row ??\n                        (defaultRange && defaultRange.lastRow) ??\n                        Number.MAX_VALUE),\n                    state: cursor.state\n                };\n                if (typeof cursor.column !== 'undefined') {\n                    range.columns = [cursor.column];\n                }\n                return range;\n            }\n            DataCursor.toRange = toRange;\n        })(DataCursor || (DataCursor = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return DataCursor;\n    });\n    _registerModule(_modules, 'Data/DataPoolDefaults.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        const DataPoolDefaults = {\n            connectors: []\n        };\n        /* *\n         *\n         *  Export Defaults\n         *\n         * */\n\n        return DataPoolDefaults;\n    });\n    _registerModule(_modules, 'Data/DataPool.js', [_modules['Data/Connectors/DataConnector.js'], _modules['Data/DataPoolDefaults.js'], _modules['Core/Utilities.js']], function (DataConnector, DataPoolDefaults, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Data pool to load connectors on-demand.\n         *\n         * @class\n         * @name Data.DataPool\n         *\n         * @param {Data.DataPoolOptions} options\n         * Pool options with all connectors.\n         */\n        class DataPool {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(options = DataPoolDefaults) {\n                options.connectors = (options.connectors || []);\n                this.connectors = {};\n                this.options = options;\n                this.waiting = {};\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Emits an event on this data pool to all registered callbacks of the given\n             * event.\n             * @private\n             *\n             * @param {DataTable.Event} e\n             * Event object with event information.\n             */\n            emit(e) {\n                U.fireEvent(this, e.type, e);\n            }\n            /**\n             * Loads the connector.\n             *\n             * @function Data.DataPool#getConnector\n             *\n             * @param {string} connectorId\n             * ID of the connector.\n             *\n             * @return {Promise<Data.DataConnector>}\n             * Returns the connector.\n             */\n            getConnector(connectorId) {\n                const connector = this.connectors[connectorId];\n                // Already loaded\n                if (connector) {\n                    return Promise.resolve(connector);\n                }\n                let waitingList = this.waiting[connectorId];\n                // Start loading\n                if (!waitingList) {\n                    waitingList = this.waiting[connectorId] = [];\n                    const connectorOptions = this.getConnectorOptions(connectorId);\n                    if (!connectorOptions) {\n                        throw new Error(`Connector '${connectorId}' not found.`);\n                    }\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    this\n                        .loadConnector(connectorOptions)\n                        .then((connector) => {\n                        delete this.waiting[connectorId];\n                        for (let i = 0, iEnd = waitingList.length; i < iEnd; ++i) {\n                            waitingList[i][0](connector);\n                        }\n                    })['catch']((error) => {\n                        delete this.waiting[connectorId];\n                        for (let i = 0, iEnd = waitingList.length; i < iEnd; ++i) {\n                            waitingList[i][1](error);\n                        }\n                    });\n                }\n                // Add request to waiting list\n                return new Promise((resolve, reject) => {\n                    waitingList.push([resolve, reject]);\n                });\n            }\n            /**\n             * Returns the IDs of all connectors.\n             *\n             * @private\n             *\n             * @return {Array<string>}\n             * Names of all connectors.\n             */\n            getConnectorIds() {\n                const connectors = this.options.connectors, connectorIds = [];\n                for (let i = 0, iEnd = connectors.length; i < iEnd; ++i) {\n                    connectorIds.push(connectors[i].id);\n                }\n                return connectorIds;\n            }\n            /**\n             * Loads the options of the connector.\n             *\n             * @private\n             *\n             * @param {string} connectorId\n             * ID of the connector.\n             *\n             * @return {DataPoolConnectorOptions|undefined}\n             * Returns the options of the connector, or `undefined` if not found.\n             */\n            getConnectorOptions(connectorId) {\n                const connectors = this.options.connectors;\n                for (let i = 0, iEnd = connectors.length; i < iEnd; ++i) {\n                    if (connectors[i].id === connectorId) {\n                        return connectors[i];\n                    }\n                }\n            }\n            /**\n             * Loads the connector table.\n             *\n             * @function Data.DataPool#getConnectorTable\n             *\n             * @param {string} connectorId\n             * ID of the connector.\n             *\n             * @return {Promise<Data.DataTable>}\n             * Returns the connector table.\n             */\n            getConnectorTable(connectorId) {\n                return this\n                    .getConnector(connectorId)\n                    .then((connector) => connector.table);\n            }\n            /**\n             * Tests whether the connector has never been requested.\n             *\n             * @param {string} connectorId\n             * Name of the connector.\n             *\n             * @return {boolean}\n             * Returns `true`, if the connector has never been requested, otherwise\n             * `false`.\n             */\n            isNewConnector(connectorId) {\n                return !this.connectors[connectorId];\n            }\n            /**\n             * Creates and loads the connector.\n             *\n             * @private\n             *\n             * @param {Data.DataPoolConnectorOptions} options\n             * Options of connector.\n             *\n             * @return {Promise<Data.DataConnector>}\n             * Returns the connector.\n             */\n            loadConnector(options) {\n                return new Promise((resolve, reject) => {\n                    this.emit({\n                        type: 'load',\n                        options\n                    });\n                    const ConnectorClass = DataConnector.types[options.type];\n                    if (!ConnectorClass) {\n                        throw new Error(`Connector type not found. (${options.type})`);\n                    }\n                    const connector = new ConnectorClass(options.options);\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                    connector\n                        .load()\n                        .then((connector) => {\n                        this.connectors[options.id] = connector;\n                        this.emit({\n                            type: 'afterLoad',\n                            options\n                        });\n                        resolve(connector);\n                    })['catch'](reject);\n                });\n            }\n            /**\n             * Registers a callback for a specific event.\n             *\n             * @function Highcharts.DataPool#on\n             *\n             * @param {string} type\n             * Event type as a string.\n             *\n             * @param {Highcharts.EventCallbackFunction<Highcharts.DataPool>} callback\n             * Function to register for an event callback.\n             *\n             * @return {Function}\n             * Function to unregister callback from the event.\n             */\n            on(type, callback) {\n                return U.addEvent(this, type, callback);\n            }\n            /**\n             * Sets connector options under the specified `options.id`.\n             *\n             * @param {Data.DataPoolConnectorOptions} options\n             * Connector options to set.\n             */\n            setConnectorOptions(options) {\n                const connectors = this.options.connectors, instances = this.connectors;\n                this.emit({\n                    type: 'setConnectorOptions',\n                    options\n                });\n                for (let i = 0, iEnd = connectors.length; i < iEnd; ++i) {\n                    if (connectors[i].id === options.id) {\n                        connectors.splice(i, 1);\n                        break;\n                    }\n                }\n                if (instances[options.id]) {\n                    instances[options.id].stopPolling();\n                    delete instances[options.id];\n                }\n                connectors.push(options);\n                this.emit({\n                    type: 'afterSetConnectorOptions',\n                    options\n                });\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Semantic version string of the DataPool class.\n         * @internal\n         */\n        DataPool.version = '1.0.0';\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return DataPool;\n    });\n    _registerModule(_modules, 'Data/Formula/FormulaParser.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * @private\n         */\n        const booleanRegExp = /^(?:FALSE|TRUE)/;\n        /**\n         * `.`-separated decimal.\n         * @private\n         */\n        const decimal1RegExp = /^[+\\-]?\\d+(?:\\.\\d+)?(?:e[+\\-]\\d+)?/;\n        /**\n         * `,`-separated decimal.\n         * @private\n         */\n        const decimal2RegExp = /^[+\\-]?\\d+(?:,\\d+)?(?:e[+\\-]\\d+)?/;\n        /**\n         * - Group 1: Function name\n         * @private\n         */\n        const functionRegExp = /^([A-Z][A-Z\\d\\.]*)\\(/;\n        /**\n         * @private\n         */\n        const operatorRegExp = /^(?:[+\\-*\\/^<=>]|<=|=>)/;\n        /**\n         * - Group 1: Start column\n         * - Group 2: Start row\n         * - Group 3: End column\n         * - Group 4: End row\n         * @private\n         */\n        const rangeA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)\\:(\\$?[A-Z]+)(\\$?\\d+)/;\n        /**\n         * - Group 1: Start row\n         * - Group 2: Start column\n         * - Group 3: End row\n         * - Group 4: End column\n         * @private\n         */\n        const rangeR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])\\:R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])/;\n        /**\n         * - Group 1: Column\n         * - Group 2: Row\n         * @private\n         */\n        const referenceA1RegExp = /^(\\$?[A-Z]+)(\\$?\\d+)(?![\\:C])/;\n        /**\n         * - Group 1: Row\n         * - Group 2: Column\n         * @private\n         */\n        const referenceR1C1RegExp = /^R(\\d*|\\[\\d+\\])C(\\d*|\\[\\d+\\])(?!\\:)/;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Extracts the inner string of the most outer parantheses.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Text string to extract from.\n         *\n         * @return {string}\n         * Extracted parantheses. If not found an exception will be thrown.\n         */\n        function extractParantheses(text) {\n            let parantheseLevel = 0;\n            for (let i = 0, iEnd = text.length, char, parantheseStart = 1; i < iEnd; ++i) {\n                char = text[i];\n                if (char === '(') {\n                    if (!parantheseLevel) {\n                        parantheseStart = i + 1;\n                    }\n                    ++parantheseLevel;\n                    continue;\n                }\n                if (char === ')') {\n                    --parantheseLevel;\n                    if (!parantheseLevel) {\n                        return text.substring(parantheseStart, i);\n                    }\n                }\n            }\n            if (parantheseLevel > 0) {\n                const error = new Error('Incomplete parantheses.');\n                error.name = 'FormulaParseError';\n                throw error;\n            }\n            return '';\n        }\n        /**\n         * Extracts the inner string value.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Text string to extract from.\n         *\n         * @return {string}\n         * Extracted string. If not found an exception will be thrown.\n         */\n        function extractString(text) {\n            let start = -1;\n            for (let i = 0, iEnd = text.length, char, escaping = false; i < iEnd; ++i) {\n                char = text[i];\n                if (char === '\\\\') {\n                    escaping = !escaping;\n                    continue;\n                }\n                if (escaping) {\n                    escaping = false;\n                    continue;\n                }\n                if (char === '\"') {\n                    if (start < 0) {\n                        start = i;\n                    }\n                    else {\n                        return text.substring(start + 1, i); // `Ã¬` is excluding\n                    }\n                }\n            }\n            const error = new Error('Incomplete string.');\n            error.name = 'FormulaParseError';\n            throw error;\n        }\n        /**\n         * Parses an argument string. Formula arrays with a single term will be\n         * simplified to the term.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Argument string to parse.\n         *\n         * @param {boolean} alternativeSeparators\n         * Whether to expect `;` as argument separator and `,` as decimal separator.\n         *\n         * @return {Formula|Function|Range|Reference|Value}\n         * The recognized term structure.\n         */\n        function parseArgument(text, alternativeSeparators) {\n            let match;\n            // Check for a R1C1:R1C1 range notation\n            match = text.match(rangeR1C1RegExp);\n            if (match) {\n                const beginColumnRelative = (match[2] === '' || match[2][0] === '[');\n                const beginRowRelative = (match[1] === '' || match[1][0] === '[');\n                const endColumnRelative = (match[4] === '' || match[4][0] === '[');\n                const endRowRelative = (match[3] === '' || match[3][0] === '[');\n                const range = {\n                    type: 'range',\n                    beginColumn: (beginColumnRelative ?\n                        parseInt(match[2].substring(1, -1) || '0', 10) :\n                        parseInt(match[2], 10) - 1),\n                    beginRow: (beginRowRelative ?\n                        parseInt(match[1].substring(1, -1) || '0', 10) :\n                        parseInt(match[1], 10) - 1),\n                    endColumn: (endColumnRelative ?\n                        parseInt(match[4].substring(1, -1) || '0', 10) :\n                        parseInt(match[4], 10) - 1),\n                    endRow: (endRowRelative ?\n                        parseInt(match[3].substring(1, -1) || '0', 10) :\n                        parseInt(match[3], 10) - 1)\n                };\n                if (beginColumnRelative) {\n                    range.beginColumnRelative = true;\n                }\n                if (beginRowRelative) {\n                    range.beginRowRelative = true;\n                }\n                if (endColumnRelative) {\n                    range.endColumnRelative = true;\n                }\n                if (endRowRelative) {\n                    range.endRowRelative = true;\n                }\n                return range;\n            }\n            // Check for a A1:A1 range notation\n            match = text.match(rangeA1RegExp);\n            if (match) {\n                const beginColumnRelative = match[1][0] !== '$';\n                const beginRowRelative = match[2][0] !== '$';\n                const endColumnRelative = match[3][0] !== '$';\n                const endRowRelative = match[4][0] !== '$';\n                const range = {\n                    type: 'range',\n                    beginColumn: parseReferenceColumn(beginColumnRelative ?\n                        match[1] :\n                        match[1].substring(1)) - 1,\n                    beginRow: parseInt(beginRowRelative ?\n                        match[2] :\n                        match[2].substring(1), 10) - 1,\n                    endColumn: parseReferenceColumn(endColumnRelative ?\n                        match[3] :\n                        match[3].substring(1)) - 1,\n                    endRow: parseInt(endRowRelative ?\n                        match[4] :\n                        match[4].substring(1), 10) - 1\n                };\n                if (beginColumnRelative) {\n                    range.beginColumnRelative = true;\n                }\n                if (beginRowRelative) {\n                    range.beginRowRelative = true;\n                }\n                if (endColumnRelative) {\n                    range.endColumnRelative = true;\n                }\n                if (endRowRelative) {\n                    range.endRowRelative = true;\n                }\n                return range;\n            }\n            // Fallback to formula processing for other pattern types\n            const formula = parseFormula(text, alternativeSeparators);\n            return (formula.length === 1 && typeof formula[0] !== 'string' ?\n                formula[0] :\n                formula);\n        }\n        /**\n         * Parse arguments string inside function parantheses.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Parantheses string of the function.\n         *\n         * @param {boolean} alternativeSeparators\n         * Whether to expect `;` as argument separator and `,` as decimal separator.\n         *\n         * @return {Highcharts.FormulaArguments}\n         * Parsed arguments array.\n         */\n        function parseArguments(text, alternativeSeparators) {\n            const args = [], argumentsSeparator = (alternativeSeparators ? ';' : ',');\n            let parantheseLevel = 0, term = '';\n            for (let i = 0, iEnd = text.length, char; i < iEnd; ++i) {\n                char = text[i];\n                // Check for separator\n                if (char === argumentsSeparator &&\n                    !parantheseLevel &&\n                    term) {\n                    args.push(parseArgument(term, alternativeSeparators));\n                    term = '';\n                    // Check for a quoted string before skip logic\n                }\n                else if (char === '\"' &&\n                    !parantheseLevel &&\n                    !term) {\n                    const string = extractString(text.substring(i));\n                    args.push(string);\n                    i += string.length + 1; // Only +1 to cover ++i in for-loop\n                    // Skip space and check paranthesis nesting\n                }\n                else if (char !== ' ') {\n                    term += char;\n                    if (char === '(') {\n                        ++parantheseLevel;\n                    }\n                    else if (char === ')') {\n                        --parantheseLevel;\n                    }\n                }\n            }\n            // Look for left-overs from last argument\n            if (!parantheseLevel && term) {\n                args.push(parseArgument(term, alternativeSeparators));\n            }\n            return args;\n        }\n        /**\n         * Converts a spreadsheet formula string into a formula array. Throws a\n         * `FormulaParserError` when the string can not be parsed.\n         *\n         * @private\n         * @function Formula.parseFormula\n         *\n         * @param {string} text\n         * Spreadsheet formula string, without the leading `=`.\n         *\n         * @param {boolean} alternativeSeparators\n         * * `false` to expect `,` between arguments and `.` in decimals.\n         * * `true` to expect `;` between arguments and `,` in decimals.\n         *\n         * @return {Formula.Formula}\n         * Formula array representing the string.\n         */\n        function parseFormula(text, alternativeSeparators) {\n            const decimalRegExp = (alternativeSeparators ?\n                decimal2RegExp :\n                decimal1RegExp), formula = [];\n            let match, next = (text[0] === '=' ? text.substring(1) : text).trim();\n            while (next) {\n                // Check for an R1C1 reference notation\n                match = next.match(referenceR1C1RegExp);\n                if (match) {\n                    const columnRelative = (match[2] === '' || match[2][0] === '[');\n                    const rowRelative = (match[1] === '' || match[1][0] === '[');\n                    const reference = {\n                        type: 'reference',\n                        column: (columnRelative ?\n                            parseInt(match[2].substring(1, -1) || '0', 10) :\n                            parseInt(match[2], 10) - 1),\n                        row: (rowRelative ?\n                            parseInt(match[1].substring(1, -1) || '0', 10) :\n                            parseInt(match[1], 10) - 1)\n                    };\n                    if (columnRelative) {\n                        reference.columnRelative = true;\n                    }\n                    if (rowRelative) {\n                        reference.rowRelative = true;\n                    }\n                    formula.push(reference);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for an A1 reference notation\n                match = next.match(referenceA1RegExp);\n                if (match) {\n                    const columnRelative = match[1][0] !== '$';\n                    const rowRelative = match[2][0] !== '$';\n                    const reference = {\n                        type: 'reference',\n                        column: parseReferenceColumn(columnRelative ?\n                            match[1] :\n                            match[1].substring(1)) - 1,\n                        row: parseInt(rowRelative ?\n                            match[2] :\n                            match[2].substring(1), 10) - 1\n                    };\n                    if (columnRelative) {\n                        reference.columnRelative = true;\n                    }\n                    if (rowRelative) {\n                        reference.rowRelative = true;\n                    }\n                    formula.push(reference);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a formula operator\n                match = next.match(operatorRegExp);\n                if (match) {\n                    formula.push(match[0]);\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a boolean value\n                match = next.match(booleanRegExp);\n                if (match) {\n                    formula.push(match[0] === 'TRUE');\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a number value\n                match = next.match(decimalRegExp);\n                if (match) {\n                    formula.push(parseFloat(match[0]));\n                    next = next.substring(match[0].length).trim();\n                    continue;\n                }\n                // Check for a quoted string\n                if (next[0] === '\"') {\n                    const string = extractString(next);\n                    formula.push(string.substring(1, -1));\n                    next = next.substring(string.length + 2).trim();\n                    continue;\n                }\n                // Check for a function\n                match = next.match(functionRegExp);\n                if (match) {\n                    next = next.substring(match[1].length).trim();\n                    const parantheses = extractParantheses(next);\n                    formula.push({\n                        type: 'function',\n                        name: match[1],\n                        args: parseArguments(parantheses, alternativeSeparators)\n                    });\n                    next = next.substring(parantheses.length + 2).trim();\n                    continue;\n                }\n                // Check for a formula in parantheses\n                if (next[0] === '(') {\n                    const paranteses = extractParantheses(next);\n                    if (paranteses) {\n                        formula\n                            .push(parseFormula(paranteses, alternativeSeparators));\n                        next = next.substring(paranteses.length + 2).trim();\n                        continue;\n                    }\n                }\n                // Something is not right\n                const position = text.length - next.length, error = new Error('Unexpected character `' +\n                    text.substring(position, position + 1) +\n                    '` at position ' + (position + 1) +\n                    '. (`...' + text.substring(position - 5, position + 6) + '...`)');\n                error.name = 'FormulaParseError';\n                throw error;\n            }\n            return formula;\n        }\n        /**\n         * Converts a reference column `A` of `A1` into a number. Supports endless sizes\n         * `ZZZ...`, just limited by integer precision.\n         *\n         * @private\n         *\n         * @param {string} text\n         * Column string to convert.\n         *\n         * @return {number}\n         * Converted column index.\n         */\n        function parseReferenceColumn(text) {\n            let column = 0;\n            for (let i = 0, iEnd = text.length, code, factor = text.length - 1; i < iEnd; ++i) {\n                code = text.charCodeAt(i);\n                if (code >= 65 && code <= 90) {\n                    column += (code - 64) * Math.pow(26, factor);\n                }\n                --factor;\n            }\n            return column;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const FormulaParser = {\n            parseFormula\n        };\n\n        return FormulaParser;\n    });\n    _registerModule(_modules, 'Data/Formula/FormulaTypes.js', [], function () {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        /**\n         * Array of all possible operators.\n         * @private\n         */\n        const operators = ['+', '-', '*', '/', '^', '=', '<', '<=', '>', '>='];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Tests an item for a Formula array.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a formula (or argument) array.\n         */\n        function isFormula(item) {\n            return item instanceof Array;\n        }\n        /**\n         * Tests an item for a Function structure.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a formula function.\n         */\n        function isFunction(item) {\n            return (typeof item === 'object' &&\n                !(item instanceof Array) &&\n                item.type === 'function');\n        }\n        /**\n         * Tests an item for an Operator string.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is an operator string.\n         */\n        function isOperator(item) {\n            return (typeof item === 'string' &&\n                operators.indexOf(item) >= 0);\n        }\n        /**\n         * Tests an item for a Range structure.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a range.\n         */\n        function isRange(item) {\n            return (typeof item === 'object' &&\n                !(item instanceof Array) &&\n                item.type === 'range');\n        }\n        /**\n         * Tests an item for a Reference structure.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a reference.\n         */\n        function isReference(item) {\n            return (typeof item === 'object' &&\n                !(item instanceof Array) &&\n                item.type === 'reference');\n        }\n        /**\n         * Tests an item for a Value structure.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaItem|null|undefined} item\n         * Item to test.\n         *\n         * @return {boolean}\n         * `true`, if the item is a value.\n         */\n        function isValue(item) {\n            return (typeof item === 'boolean' ||\n                typeof item === 'number' ||\n                typeof item === 'string');\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MathFormula = {\n            isFormula,\n            isFunction,\n            isOperator,\n            isRange,\n            isReference,\n            isValue\n        };\n\n        return MathFormula;\n    });\n    _registerModule(_modules, 'Data/Formula/FormulaProcessor.js', [_modules['Data/Formula/FormulaTypes.js']], function (FormulaTypes) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { isFormula, isFunction, isOperator, isRange, isReference, isValue } = FormulaTypes;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const asLogicalStringRegExp = / */;\n        const MAX_FALSE = Number.MAX_VALUE / 1.000000000001;\n        const MAX_STRING = Number.MAX_VALUE / 1.000000000002;\n        const MAX_TRUE = Number.MAX_VALUE;\n        const operatorPriority = {\n            '^': 3,\n            '*': 2,\n            '/': 2,\n            '+': 1,\n            '-': 1,\n            '=': 0,\n            '<': 0,\n            '<=': 0,\n            '>': 0,\n            '>=': 0\n        };\n        const processorFunctions = {};\n        const processorFunctionNameRegExp = /^[A-Z][A-Z\\.]*$/;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Converts non-number types to logical numbers.\n         *\n         * @param {Highcharts.FormulaValue} value\n         * Value to convert.\n         *\n         * @return {number}\n         * Logical number value. `NaN` if not convertable.\n         */\n        function asLogicalNumber(value) {\n            switch (typeof value) {\n                case 'boolean':\n                    return value ? MAX_TRUE : MAX_FALSE;\n                case 'string':\n                    return MAX_STRING;\n                case 'number':\n                    return value;\n                default:\n                    return NaN;\n            }\n        }\n        /**\n         * Converts strings to logical strings, while other types get passed through. In\n         * logical strings the space character is the lowest value and letters are case\n         * insensitive.\n         *\n         * @param {Highcharts.FormulaValue} value\n         * Value to convert.\n         *\n         * @return {Highcharts.FormulaValue}\n         * Logical string value or passed through value.\n         */\n        function asLogicalString(value) {\n            if (typeof value === 'string') {\n                return value.toLowerCase().replace(asLogicalStringRegExp, '\\0');\n            }\n            return value;\n        }\n        /**\n         * Converts non-number types to a logic number.\n         *\n         * @param {Highcharts.FormulaValue} value\n         * Value to convert.\n         *\n         * @return {number}\n         * Number value. `NaN` if not convertable.\n         */\n        function asNumber(value) {\n            switch (typeof value) {\n                case 'boolean':\n                    return value ? 1 : 0;\n                case 'string':\n                    return parseFloat(value.replace(',', '.'));\n                case 'number':\n                    return value;\n                default:\n                    return NaN;\n            }\n        }\n        /**\n         * Process a basic operation of two given values.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaOperator} operator\n         * Operator between values.\n         *\n         * @param {Highcharts.FormulaValue} x\n         * First value for operation.\n         *\n         * @param {Highcharts.FormulaValue} y\n         * Second value for operation.\n         *\n         * @return {Highcharts.FormulaValue}\n         * Operation result. `NaN` if operation is not support.\n         */\n        function basicOperation(operator, x, y) {\n            switch (operator) {\n                case '=':\n                    return asLogicalString(x) === asLogicalString(y);\n                case '<':\n                    if (typeof x === typeof y) {\n                        return asLogicalString(x) < asLogicalString(y);\n                    }\n                    return asLogicalNumber(x) < asLogicalNumber(y);\n                case '<=':\n                    if (typeof x === typeof y) {\n                        return asLogicalString(x) <= asLogicalString(y);\n                    }\n                    return asLogicalNumber(x) <= asLogicalNumber(y);\n                case '>':\n                    if (typeof x === typeof y) {\n                        return asLogicalString(x) > asLogicalString(y);\n                    }\n                    return asLogicalNumber(x) > asLogicalNumber(y);\n                case '>=':\n                    if (typeof x === typeof y) {\n                        return asLogicalString(x) >= asLogicalString(y);\n                    }\n                    return asLogicalNumber(x) >= asLogicalNumber(y);\n            }\n            x = asNumber(x);\n            y = asNumber(y);\n            let result;\n            switch (operator) {\n                case '+':\n                    result = x + y;\n                    break;\n                case '-':\n                    result = x - y;\n                    break;\n                case '*':\n                    result = x * y;\n                    break;\n                case '/':\n                    result = x / y;\n                    break;\n                case '^':\n                    result = Math.pow(x, y);\n                    break;\n                default:\n                    return NaN;\n            }\n            // Limit decimal to 9 digits\n            return (result % 1 ?\n                Math.round(result * 1000000000) / 1000000000 :\n                result);\n        }\n        /**\n         * Converts an argument to Value and in case of a range to an array of Values.\n         *\n         * @function Highcharts.Formula.getArgumentValue\n         *\n         * @param {Highcharts.FormulaRange|Highcharts.FormulaTerm} arg\n         * Formula range or term to convert.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n         * Converted value.\n         */\n        function getArgumentValue(arg, table) {\n            // Add value\n            if (isValue(arg)) {\n                return arg;\n            }\n            // Add values of a range\n            if (isRange(arg)) {\n                return (table && getRangeValues(arg, table) || []);\n            }\n            // Add values of a function\n            if (isFunction(arg)) {\n                return processFunction(arg, table);\n            }\n            // Process functions, operations, references with formula processor\n            return processFormula((isFormula(arg) ? arg : [arg]), table);\n        }\n        /**\n         * Converts all arguments to Values and in case of ranges to arrays of Values.\n         *\n         * @function Highcharts.Formula.getArgumentsValues\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Formula arguments to convert.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Array<(Highcharts.FormulaValue|Array<Highcharts.FormulaValue>)>}\n         * Converted values.\n         */\n        function getArgumentsValues(args, table) {\n            const values = [];\n            for (let i = 0, iEnd = args.length; i < iEnd; ++i) {\n                values.push(getArgumentValue(args[i], table));\n            }\n            return values;\n        }\n        /**\n         * Extracts cell values from a table for a given range.\n         *\n         * @function Highcharts.Formula.getRangeValues\n         *\n         * @param {Highcharts.FormulaRange} range\n         * Formula range to use.\n         *\n         * @param {Highcharts.DataTable} table\n         * Table to extract from.\n         *\n         * @return {Array<Highcharts.FormulaValue>}\n         * Extracted values.\n         */\n        function getRangeValues(range, table) {\n            const columnNames = table\n                .getColumnNames()\n                .slice(range.beginColumn, range.endColumn + 1), values = [];\n            for (let i = 0, iEnd = columnNames.length, cell; i < iEnd; ++i) {\n                const cells = table.getColumn(columnNames[i], true) || [];\n                for (let j = range.beginRow, jEnd = range.endRow + 1; j < jEnd; ++j) {\n                    cell = cells[j];\n                    if (typeof cell === 'string' &&\n                        cell[0] === '=' &&\n                        table !== table.modified) {\n                        // Look in the modified table for formula result\n                        cell = table.modified.getCell(columnNames[i], j);\n                    }\n                    values.push(isValue(cell) ? cell : NaN);\n                }\n            }\n            return values;\n        }\n        /**\n         * Extracts the cell value from a table for a given reference.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaReference} reference\n         * Formula reference to use.\n         *\n         * @param {Highcharts.DataTable} table\n         * Table to extract from.\n         *\n         * @return {Highcharts.FormulaValue}\n         * Extracted value. 'undefined' might also indicate that the cell was not found.\n         */\n        function getReferenceValue(reference, table) {\n            const columnName = table.getColumnNames()[reference.column];\n            if (columnName) {\n                const cell = table.getCell(columnName, reference.row);\n                if (typeof cell === 'string' &&\n                    cell[0] === '=' &&\n                    table !== table.modified) {\n                    // Look in the modified table for formula result\n                    const result = table.modified.getCell(columnName, reference.row);\n                    return isValue(result) ? result : NaN;\n                }\n                return isValue(cell) ? cell : NaN;\n            }\n            return NaN;\n        }\n        /**\n         * Processes a formula array on the given table. If the formula does not contain\n         * references or ranges, then no table has to be provided.\n         *\n         * @private\n         * @function Highcharts.processFormula\n         *\n         * @param {Highcharts.Formula} formula\n         * Formula array to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Highcharts.FormulaValue}\n         * Result value of the process. `NaN` indicates an error.\n         */\n        function processFormula(formula, table) {\n            let x;\n            for (let i = 0, iEnd = formula.length, item, operator, result, y; i < iEnd; ++i) {\n                item = formula[i];\n                // Remember operator for operation on next item\n                if (isOperator(item)) {\n                    operator = item;\n                    continue;\n                }\n                // Next item is a value\n                if (isValue(item)) {\n                    y = item;\n                    // Next item is a formula and needs to get processed first\n                }\n                else if (isFormula(item)) {\n                    y = processFormula(formula, table);\n                    // Next item is a function call and needs to get processed first\n                }\n                else if (isFunction(item)) {\n                    result = processFunction(item, table);\n                    y = (isValue(result) ? result : NaN); // Arrays are not allowed here\n                    // Next item is a reference and needs to get resolved\n                }\n                else if (isReference(item)) {\n                    y = (table && getReferenceValue(item, table));\n                }\n                // If we have a next value, lets do the operation\n                if (typeof y !== 'undefined') {\n                    // Next value is our first value\n                    if (typeof x === 'undefined') {\n                        if (operator) {\n                            x = basicOperation(operator, 0, y);\n                        }\n                        else {\n                            x = y;\n                        }\n                        // Fail fast if no operator available\n                    }\n                    else if (!operator) {\n                        return NaN;\n                        // Regular next value\n                    }\n                    else {\n                        const operator2 = formula[i + 1];\n                        if (isOperator(operator2) &&\n                            operatorPriority[operator2] > operatorPriority[operator]) {\n                            y = basicOperation(operator2, y, processFormula(formula.slice(i + 2)));\n                            i = iEnd;\n                        }\n                        x = basicOperation(operator, x, y);\n                    }\n                    operator = void 0;\n                    y = void 0;\n                }\n            }\n            return isValue(x) ? x : NaN;\n        }\n        /**\n         * Process a function on the given table. If the arguments do not contain\n         * references or ranges, then no table has to be provided.\n         *\n         * @private\n         *\n         * @param {Highcharts.FormulaFunction} formulaFunction\n         * Formula function to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @param {Highcharts.FormulaReference} [reference]\n         * Table cell reference to use for relative references and ranges.\n         *\n         * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n         * Result value (or values) of the process. `NaN` indicates an error.\n         */\n        function processFunction(formulaFunction, table, \n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        reference // @todo\n        ) {\n            const processor = processorFunctions[formulaFunction.name];\n            if (processor) {\n                try {\n                    return processor(formulaFunction.args, table);\n                }\n                catch {\n                    return NaN;\n                }\n            }\n            const error = new Error(`Function \"${formulaFunction.name}\" not found.`);\n            error.name = 'FormulaProcessError';\n            throw error;\n        }\n        /**\n         * Registers a function for the FormulaProcessor.\n         *\n         * @param {string} name\n         * Name of the function in spreadsheets notation with upper case.\n         *\n         * @param {Highcharts.FormulaFunction} processorFunction\n         * ProcessorFunction for the FormulaProcessor. This is an object so that it\n         * can take additional parameter for future validation routines.\n         *\n         * @return {boolean}\n         * Return true, if the ProcessorFunction has been registered.\n         */\n        function registerProcessorFunction(name, processorFunction) {\n            return (processorFunctionNameRegExp.test(name) &&\n                !processorFunctions[name] &&\n                !!(processorFunctions[name] = processorFunction));\n        }\n        /**\n         * Translates relative references and ranges in-place.\n         *\n         * @param {Highcharts.Formula} formula\n         * Formula to translate references and ranges in.\n         *\n         * @param {number} [columnDelta=0]\n         * Column delta to translate to. Negative translate back.\n         *\n         * @param {number} [rowDelta=0]\n         * Row delta to translate to. Negative numbers translate back.\n         *\n         * @return {Highcharts.Formula}\n         * Formula with translated reference and ranges. This formula is equal to the\n         * first argument.\n         */\n        function translateReferences(formula, columnDelta = 0, rowDelta = 0) {\n            for (let i = 0, iEnd = formula.length, item; i < iEnd; ++i) {\n                item = formula[i];\n                if (item instanceof Array) {\n                    translateReferences(item, columnDelta, rowDelta);\n                }\n                else if (isFunction(item)) {\n                    translateReferences(item.args, columnDelta, rowDelta);\n                }\n                else if (isRange(item)) {\n                    if (item.beginColumnRelative) {\n                        item.beginColumn += columnDelta;\n                    }\n                    if (item.beginRowRelative) {\n                        item.beginRow += rowDelta;\n                    }\n                    if (item.endColumnRelative) {\n                        item.endColumn += columnDelta;\n                    }\n                    if (item.endRowRelative) {\n                        item.endRow += rowDelta;\n                    }\n                }\n                else if (isReference(item)) {\n                    if (item.columnRelative) {\n                        item.column += columnDelta;\n                    }\n                    if (item.rowRelative) {\n                        item.row += rowDelta;\n                    }\n                }\n            }\n            return formula;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const FormulaProcessor = {\n            asNumber,\n            getArgumentValue,\n            getArgumentsValues,\n            getRangeValues,\n            getReferenceValue,\n            processFormula,\n            processorFunctions,\n            registerProcessorFunction,\n            translateReferences\n        };\n\n        return FormulaProcessor;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/ABS.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `ABS(value)` implementation. Returns positive numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Array<number>}\n         * Result value of the process.\n         */\n        function ABS(args, table) {\n            const value = getArgumentValue(args[0], table);\n            switch (typeof value) {\n                case 'number':\n                    return Math.abs(value);\n                case 'object': {\n                    const values = [];\n                    for (let i = 0, iEnd = value.length, value2; i < iEnd; ++i) {\n                        value2 = value[i];\n                        if (typeof value2 !== 'number') {\n                            return NaN;\n                        }\n                        values.push(Math.abs(value2));\n                    }\n                    return values;\n                }\n                default:\n                    return NaN;\n            }\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('ABS', ABS);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ABS;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AND.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AND(...tests)` implementation. Returns `TRUE`, if all test\n         * results are not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function AND(args, table) {\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                if (!value ||\n                    (typeof value === 'object' &&\n                        !AND(value, table))) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AND', AND);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AND;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AVERAGE.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentsValues } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AVERAGE(...values)` implementation. Calculates the average\n         * of the given values that are numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.AVERAGE\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function AVERAGE(args, table) {\n            const values = getArgumentsValues(args, table);\n            let count = 0, result = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            ++count;\n                            result += value;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            if (typeof value2 === 'number' &&\n                                !isNaN(value2)) {\n                                ++count;\n                                result += value2;\n                            }\n                        }\n                        break;\n                }\n            }\n            return (count ? (result / count) : 0);\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AVERAGE', AVERAGE);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AVERAGE;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/AVERAGEA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `AVERAGEA(...values)` implementation. Calculates the\n         * average of the given values. Strings and FALSE are calculated as 0.\n         *\n         * @private\n         * @function Formula.processorFunctions.AVERAGEA\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function AVERAGEA(args, table) {\n            let count = 0, result = 0;\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                switch (typeof value) {\n                    case 'boolean':\n                        ++count;\n                        result += (value ? 1 : 0);\n                        continue;\n                    case 'number':\n                        if (!isNaN(value)) {\n                            ++count;\n                            result += value;\n                        }\n                        continue;\n                    case 'string':\n                        ++count;\n                        continue;\n                    default:\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            switch (typeof value2) {\n                                case 'boolean':\n                                    ++count;\n                                    result += (value2 ? 1 : 0);\n                                    continue;\n                                case 'number':\n                                    if (!isNaN(value2)) {\n                                        ++count;\n                                        result += value2;\n                                    }\n                                    continue;\n                                case 'string':\n                                    ++count;\n                                    continue;\n                            }\n                        }\n                        continue;\n                }\n            }\n            return (count ? (result / count) : 0);\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('AVERAGEA', AVERAGEA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return AVERAGEA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/COUNT.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `COUNT(...values)` implementation. Returns the count of\n         * given values that are numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.COUNT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function COUNT(args, table) {\n            const values = FormulaProcessor.getArgumentsValues(args, table);\n            let count = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            ++count;\n                        }\n                        break;\n                    case 'object':\n                        count += COUNT(value, table);\n                        break;\n                }\n            }\n            return count;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('COUNT', COUNT);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return COUNT;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/COUNTA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `COUNTA(...values)` implementation. Returns the count of\n         * given values that are not empty.\n         *\n         * @private\n         * @function Formula.processorFunctions.COUNT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function COUNTA(args, table) {\n            const values = FormulaProcessor.getArgumentsValues(args, table);\n            let count = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (isNaN(value)) {\n                            continue;\n                        }\n                        break;\n                    case 'object':\n                        count += COUNTA(value, table);\n                        continue;\n                    case 'string':\n                        if (!value) {\n                            continue;\n                        }\n                        break;\n                }\n                ++count;\n            }\n            return count;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('COUNTA', COUNTA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return COUNTA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/IF.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `IF(test, value1, value2)` implementation. Returns one of\n         * the values based on the test result. `value1` will be returned, if the test\n         * result is not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.IF\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {Highcharts.FormulaValue|Array<Highcharts.FormulaValue>}\n         * Result value of the process.\n         */\n        function IF(args, table) {\n            return (getArgumentValue(args[0], table) ?\n                getArgumentValue(args[1], table) :\n                getArgumentValue(args[2], table));\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('IF', IF);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return IF;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/ISNA.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `ISNA(value)` implementation. Returns TRUE if value is not\n         * a number.\n         *\n         * @private\n         * @function Formula.processorFunctions.ISNA\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function ISNA(args, table) {\n            const value = getArgumentValue(args[0], table);\n            return (typeof value !== 'number' || isNaN(value));\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('ISNA', ISNA);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ISNA;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MAX.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentsValues } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MAX(...values)` implementation. Calculates the largest\n         * of the given values that are numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.MAX\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MAX(args, table) {\n            const values = getArgumentsValues(args, table);\n            let result = Number.NEGATIVE_INFINITY;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (value > result) {\n                            result = value;\n                        }\n                        break;\n                    case 'object':\n                        value = MAX(value);\n                        if (value > result) {\n                            result = value;\n                        }\n                        break;\n                }\n            }\n            return isFinite(result) ? result : 0;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MAX', MAX);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MAX;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MEDIAN.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MEDIAN(...values)` implementation. Calculates the median\n         * average of the given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MEDIAN\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MEDIAN(args, table) {\n            const median = [], values = FormulaProcessor.getArgumentsValues(args, table);\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            median.push(value);\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            if (typeof value2 === 'number' &&\n                                !isNaN(value2)) {\n                                median.push(value2);\n                            }\n                        }\n                        break;\n                }\n            }\n            const count = median.length;\n            if (!count) {\n                return NaN;\n            }\n            const half = Math.floor(count / 2); // Floor because index starts at 0\n            return (count % 2 ?\n                median[half] : // Odd\n                (median[half - 1] + median[half]) / 2 // Even\n            );\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MEDIAN', MEDIAN);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MEDIAN;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MIN.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentsValues } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MIN(...values)` implementation. Calculates the lowest\n         * of the given values that are numbers.\n         *\n         * @private\n         * @function Formula.processorFunctions.MIN\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MIN(args, table) {\n            const values = getArgumentsValues(args, table);\n            let result = Number.POSITIVE_INFINITY;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (value < result) {\n                            result = value;\n                        }\n                        break;\n                    case 'object':\n                        value = MIN(value);\n                        if (value < result) {\n                            result = value;\n                        }\n                        break;\n                }\n            }\n            return isFinite(result) ? result : 0;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MIN', MIN);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MIN;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MOD.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `MOD(value1, value2)` implementation. Calculates the rest\n         * of the division with the given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MOD\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function MOD(args, table) {\n            let value1 = getArgumentValue(args[0], table), value2 = getArgumentValue(args[1], table);\n            if (typeof value1 === 'object') {\n                value1 = value1[0];\n            }\n            if (typeof value2 === 'object') {\n                value2 = value2[0];\n            }\n            if (typeof value1 !== 'number' ||\n                typeof value2 !== 'number' ||\n                value2 === 0) {\n                return NaN;\n            }\n            return value1 % value2;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MOD', MOD);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MOD;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/MODE.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Creates the mode map of the given arguments.\n         *\n         * @private\n         * @function Formula.processorFunctions.MULT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function getModeMap(args, table) {\n            const modeMap = {}, values = FormulaProcessor.getArgumentsValues(args, table);\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            modeMap[value] = (modeMap[value] || 0) + 1;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            if (typeof value2 === 'number' &&\n                                !isNaN(value2)) {\n                                modeMap[value2] = (modeMap[value2] || 0) + 1;\n                            }\n                        }\n                        break;\n                }\n            }\n            return modeMap;\n        }\n        /**\n         * Processor for the `MODE.MULT(...values)` implementation. Calculates the most\n         * frequent values of the give values.\n         *\n         * @private\n         * @function Formula.processorFunctions.MULT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number|Array<number>}\n         * Result value of the process.\n         */\n        function MULT(args, table) {\n            const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n            if (!keys.length) {\n                return NaN;\n            }\n            let modeKeys = [parseFloat(keys[0])], modeCount = modeMap[keys[0]];\n            for (let i = 1, iEnd = keys.length, key, count; i < iEnd; ++i) {\n                key = keys[i];\n                count = modeMap[key];\n                if (modeCount < count) {\n                    modeKeys = [parseFloat(key)];\n                    modeCount = count;\n                }\n                else if (modeCount === count) {\n                    modeKeys.push(parseFloat(key));\n                }\n            }\n            return modeCount > 1 ? modeKeys : NaN;\n        }\n        /**\n         * Processor for the `MODE.SNGL(...values)` implementation. Calculates the\n         * lowest most frequent value of the give values.\n         *\n         * @private\n         * @function Formula.processorFunctions['MODE.SNGL']\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function SNGL(args, table) {\n            const modeMap = getModeMap(args, table), keys = Object.keys(modeMap);\n            if (!keys.length) {\n                return NaN;\n            }\n            let modeKey = parseFloat(keys[0]), modeCount = modeMap[keys[0]];\n            for (let i = 1, iEnd = keys.length, key, keyValue, count; i < iEnd; ++i) {\n                key = keys[i];\n                count = modeMap[key];\n                if (modeCount < count) {\n                    modeKey = parseFloat(key);\n                    modeCount = count;\n                }\n                else if (modeCount === count) {\n                    keyValue = parseFloat(key);\n                    if (modeKey > keyValue) {\n                        modeKey = keyValue;\n                        modeCount = count;\n                    }\n                }\n            }\n            return modeCount > 1 ? modeKey : NaN;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('MODE', SNGL);\n        FormulaProcessor.registerProcessorFunction('MODE.MULT', MULT);\n        FormulaProcessor.registerProcessorFunction('MODE.SNGL', SNGL);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const MODE = {\n            MULT,\n            SNGL\n        };\n\n        return MODE;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/NOT.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `NOT(value)` implementation. Returns the opposite test\n         * result.\n         *\n         * @private\n         * @function Formula.processorFunctions.NOT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean|number}\n         * Result value of the process.\n         */\n        function NOT(args, table) {\n            let value = getArgumentValue(args[0], table);\n            if (typeof value === 'object') {\n                value = value[0];\n            }\n            switch (typeof value) {\n                case 'boolean':\n                case 'number':\n                    return !value;\n            }\n            return NaN;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('NOT', NOT);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return NOT;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/OR.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `OR(...tests)` implementation. Returns `TRUE`, if one test\n         * result is not `0` or `FALSE`.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean}\n         * Result value of the process.\n         */\n        function OR(args, table) {\n            for (let i = 0, iEnd = args.length, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                if (typeof value === 'object') {\n                    if (OR(value, table)) {\n                        return true;\n                    }\n                }\n                else if (value) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('OR', OR);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return OR;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/PRODUCT.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentsValues } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `PRODUCT(...values)` implementation. Calculates the product\n         * of the given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.PRODUCT\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function PRODUCT(args, table) {\n            const values = getArgumentsValues(args, table);\n            let result = 1, calculated = false;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            calculated = true;\n                            result *= value;\n                        }\n                        break;\n                    case 'object':\n                        calculated = true;\n                        result *= PRODUCT(value, table);\n                        break;\n                }\n            }\n            return (calculated ? result : 0);\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('PRODUCT', PRODUCT);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return PRODUCT;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/SUM.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `SUM(...values)` implementation. Calculates the sum of the\n         * given values.\n         *\n         * @private\n         * @function Formula.processorFunctions.SUM\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to process.\n         *\n         * @return {number}\n         * Result value of the process.\n         */\n        function SUM(args, table) {\n            const values = FormulaProcessor.getArgumentsValues(args, table);\n            let result = 0;\n            for (let i = 0, iEnd = values.length, value; i < iEnd; ++i) {\n                value = values[i];\n                switch (typeof value) {\n                    case 'number':\n                        if (!isNaN(value)) {\n                            result += value;\n                        }\n                        break;\n                    case 'object':\n                        result += SUM(value, table);\n                        break;\n                }\n            }\n            return result;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('SUM', SUM); // ð\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SUM;\n    });\n    _registerModule(_modules, 'Data/Formula/Functions/XOR.js', [_modules['Data/Formula/FormulaProcessor.js']], function (FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { getArgumentValue } = FormulaProcessor;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Processor for the `XOR(...tests)` implementation. Returns `TRUE`, if at least\n         * one of the given tests differs in result of other tests.\n         *\n         * @private\n         * @function Formula.processorFunctions.AND\n         *\n         * @param {Highcharts.FormulaArguments} args\n         * Arguments to process.\n         *\n         * @param {Highcharts.DataTable} [table]\n         * Table to use for references and ranges.\n         *\n         * @return {boolean|number}\n         * Result value of the process.\n         */\n        function XOR(args, table) {\n            for (let i = 0, iEnd = args.length, lastValue, value; i < iEnd; ++i) {\n                value = getArgumentValue(args[i], table);\n                switch (typeof value) {\n                    case 'boolean':\n                    case 'number':\n                        if (typeof lastValue === 'undefined') {\n                            lastValue = !!value;\n                        }\n                        else if (!!value !== lastValue) {\n                            return true;\n                        }\n                        break;\n                    case 'object':\n                        for (let j = 0, jEnd = value.length, value2; j < jEnd; ++j) {\n                            value2 = value[j];\n                            switch (typeof value2) {\n                                case 'boolean':\n                                case 'number':\n                                    if (typeof lastValue === 'undefined') {\n                                        lastValue = !!value2;\n                                    }\n                                    else if (!!value2 !== lastValue) {\n                                        return true;\n                                    }\n                                    break;\n                            }\n                        }\n                        break;\n                }\n            }\n            return false;\n        }\n        /* *\n         *\n         *  Registry\n         *\n         * */\n        FormulaProcessor.registerProcessorFunction('XOR', XOR);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return XOR;\n    });\n    _registerModule(_modules, 'Data/Formula/Formula.js', [_modules['Data/Formula/FormulaParser.js'], _modules['Data/Formula/FormulaProcessor.js'], _modules['Data/Formula/FormulaTypes.js']], function (FormulaParser, FormulaProcessor, FormulaType) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /**\n         * Formula engine to make use of spreadsheet formula strings.\n         * @internal\n         */\n        const Formula = {\n            ...FormulaParser,\n            ...FormulaProcessor,\n            ...FormulaType\n        };\n\n        return Formula;\n    });\n    _registerModule(_modules, 'Data/Converters/CSVConverter.js', [_modules['Data/Converters/DataConverter.js'], _modules['Core/Utilities.js']], function (DataConverter, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Torstein HÃ¸nsi\n         *  - Christer Vasseng\n         *  - GÃ¸ran Slettemark\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Handles parsing and transforming CSV to a table.\n         *\n         * @private\n         */\n        class CSVConverter extends DataConverter {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the CSV parser.\n             *\n             * @param {CSVConverter.UserOptions} [options]\n             * Options for the CSV parser.\n             */\n            constructor(options) {\n                const mergedOptions = merge(CSVConverter.defaultOptions, options);\n                super(mergedOptions);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.columns = [];\n                this.headers = [];\n                this.dataTypes = [];\n                this.options = mergedOptions;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Creates a CSV string from the datatable on the connector instance.\n             *\n             * @param {DataConnector} connector\n             * Connector instance to export from.\n             *\n             * @param {CSVConverter.Options} [options]\n             * Options used for the export.\n             *\n             * @return {string}\n             * CSV string from the connector table.\n             */\n            export(connector, options = this.options) {\n                const { useLocalDecimalPoint, lineDelimiter } = options, exportNames = (this.options.firstRowAsNames !== false);\n                let { decimalPoint, itemDelimiter } = options;\n                if (!decimalPoint) {\n                    decimalPoint = (itemDelimiter !== ',' && useLocalDecimalPoint ?\n                        (1.1).toLocaleString()[1] :\n                        '.');\n                }\n                if (!itemDelimiter) {\n                    itemDelimiter = (decimalPoint === ',' ? ';' : ',');\n                }\n                const columns = connector.getSortedColumns(options.usePresentationOrder), columnNames = Object.keys(columns), csvRows = [], columnsCount = columnNames.length;\n                const rowArray = [];\n                // Add the names as the first row if they should be exported\n                if (exportNames) {\n                    csvRows.push(columnNames.map((columnName) => `\"${columnName}\"`).join(itemDelimiter));\n                }\n                for (let columnIndex = 0; columnIndex < columnsCount; columnIndex++) {\n                    const columnName = columnNames[columnIndex], column = columns[columnName], columnLength = column.length;\n                    const columnMeta = connector.whatIs(columnName);\n                    let columnDataType;\n                    if (columnMeta) {\n                        columnDataType = columnMeta.dataType;\n                    }\n                    for (let rowIndex = 0; rowIndex < columnLength; rowIndex++) {\n                        let cellValue = column[rowIndex];\n                        if (!rowArray[rowIndex]) {\n                            rowArray[rowIndex] = [];\n                        }\n                        // Prefer datatype from metadata\n                        if (columnDataType === 'string') {\n                            cellValue = '\"' + cellValue + '\"';\n                        }\n                        else if (typeof cellValue === 'number') {\n                            cellValue = String(cellValue).replace('.', decimalPoint);\n                        }\n                        else if (typeof cellValue === 'string') {\n                            cellValue = `\"${cellValue}\"`;\n                        }\n                        rowArray[rowIndex][columnIndex] = cellValue;\n                        // On the final column, push the row to the CSV\n                        if (columnIndex === columnsCount - 1) {\n                            // Trim repeated undefined values starting at the end\n                            // Currently, we export the first \"comma\" even if the\n                            // second value is undefined\n                            let i = columnIndex;\n                            while (rowArray[rowIndex].length > 2) {\n                                const cellVal = rowArray[rowIndex][i];\n                                if (cellVal !== void 0) {\n                                    break;\n                                }\n                                rowArray[rowIndex].pop();\n                                i--;\n                            }\n                            csvRows.push(rowArray[rowIndex].join(itemDelimiter));\n                        }\n                    }\n                }\n                return csvRows.join(lineDelimiter);\n            }\n            /**\n             * Initiates parsing of CSV\n             *\n             * @param {CSVConverter.UserOptions}[options]\n             * Options for the parser\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits CSVDataParser#parse\n             * @emits CSVDataParser#afterParse\n             */\n            parse(options, eventDetail) {\n                const converter = this, dataTypes = converter.dataTypes, parserOptions = merge(this.options, options), { beforeParse, lineDelimiter, firstRowAsNames, itemDelimiter } = parserOptions;\n                let lines, rowIt = 0, { csv, startRow, endRow } = parserOptions, column;\n                converter.columns = [];\n                converter.emit({\n                    type: 'parse',\n                    columns: converter.columns,\n                    detail: eventDetail,\n                    headers: converter.headers\n                });\n                if (csv && beforeParse) {\n                    csv = beforeParse(csv);\n                }\n                if (csv) {\n                    lines = csv\n                        .replace(/\\r\\n|\\r/g, '\\n') // Windows | Mac\n                        .split(lineDelimiter || '\\n');\n                    if (!startRow || startRow < 0) {\n                        startRow = 0;\n                    }\n                    if (!endRow || endRow >= lines.length) {\n                        endRow = lines.length - 1;\n                    }\n                    if (!itemDelimiter) {\n                        converter.guessedItemDelimiter =\n                            converter.guessDelimiter(lines);\n                    }\n                    // If the first row contain names, add them to the\n                    // headers array and skip the row.\n                    if (firstRowAsNames) {\n                        const headers = lines[0].split(itemDelimiter || converter.guessedItemDelimiter || ',');\n                        // Remove \"\"s from the headers\n                        for (let i = 0; i < headers.length; i++) {\n                            headers[i] = headers[i].trim().replace(/^[\"']|[\"']$/g, '');\n                        }\n                        converter.headers = headers;\n                        startRow++;\n                    }\n                    let offset = 0;\n                    for (rowIt = startRow; rowIt <= endRow; rowIt++) {\n                        if (lines[rowIt][0] === '#') {\n                            offset++;\n                        }\n                        else {\n                            converter\n                                .parseCSVRow(lines[rowIt], rowIt - startRow - offset);\n                        }\n                    }\n                    if (dataTypes.length &&\n                        dataTypes[0].length &&\n                        dataTypes[0][1] === 'date' && // Format is a string date\n                        !converter.options.dateFormat) {\n                        converter.deduceDateFormat(converter.columns[0], null, true);\n                    }\n                    // Guess types.\n                    for (let i = 0, iEnd = converter.columns.length; i < iEnd; ++i) {\n                        column = converter.columns[i];\n                        for (let j = 0, jEnd = column.length; j < jEnd; ++j) {\n                            if (column[j] && typeof column[j] === 'string') {\n                                let cellValue = converter.asGuessedType(column[j]);\n                                if (cellValue instanceof Date) {\n                                    cellValue = cellValue.getTime();\n                                }\n                                converter.columns[i][j] = cellValue;\n                            }\n                        }\n                    }\n                }\n                converter.emit({\n                    type: 'afterParse',\n                    columns: converter.columns,\n                    detail: eventDetail,\n                    headers: converter.headers\n                });\n            }\n            /**\n             * Internal method that parses a single CSV row\n             */\n            parseCSVRow(columnStr, rowNumber) {\n                const converter = this, columns = converter.columns || [], dataTypes = converter.dataTypes, { startColumn, endColumn } = converter.options, itemDelimiter = (converter.options.itemDelimiter ||\n                    converter.guessedItemDelimiter);\n                let { decimalPoint } = converter.options;\n                if (!decimalPoint || decimalPoint === itemDelimiter) {\n                    decimalPoint = converter.guessedDecimalPoint || '.';\n                }\n                let i = 0, c = '', token = '', actualColumn = 0, column = 0;\n                const read = (j) => {\n                    c = columnStr[j];\n                };\n                const pushType = (type) => {\n                    if (dataTypes.length < column + 1) {\n                        dataTypes.push([type]);\n                    }\n                    if (dataTypes[column][dataTypes[column].length - 1] !== type) {\n                        dataTypes[column].push(type);\n                    }\n                };\n                const push = () => {\n                    if (startColumn > actualColumn || actualColumn > endColumn) {\n                        // Skip this column, but increment the column count (#7272)\n                        ++actualColumn;\n                        token = '';\n                        return;\n                    }\n                    // Save the type of the token.\n                    if (typeof token === 'string') {\n                        if (!isNaN(parseFloat(token)) && isFinite(token)) {\n                            token = parseFloat(token);\n                            pushType('number');\n                        }\n                        else if (!isNaN(Date.parse(token))) {\n                            token = token.replace(/\\//g, '-');\n                            pushType('date');\n                        }\n                        else {\n                            pushType('string');\n                        }\n                    }\n                    else {\n                        pushType('number');\n                    }\n                    if (columns.length < column + 1) {\n                        columns.push([]);\n                    }\n                    // Try to apply the decimal point, and check if the token then is a\n                    // number. If not, reapply the initial value\n                    if (typeof token !== 'number' &&\n                        converter.guessType(token) !== 'number' &&\n                        decimalPoint) {\n                        const initialValue = token;\n                        token = token.replace(decimalPoint, '.');\n                        if (converter.guessType(token) !== 'number') {\n                            token = initialValue;\n                        }\n                    }\n                    columns[column][rowNumber] = token;\n                    token = '';\n                    ++column;\n                    ++actualColumn;\n                };\n                if (!columnStr.trim().length) {\n                    return;\n                }\n                if (columnStr.trim()[0] === '#') {\n                    return;\n                }\n                for (; i < columnStr.length; i++) {\n                    read(i);\n                    if (c === '#') {\n                        // If there are hexvalues remaining (#13283)\n                        if (!/^#[A-F\\d]{3,3}|[A-F\\d]{6,6}/i.test(columnStr.substring(i))) {\n                            // The rest of the row is a comment\n                            push();\n                            return;\n                        }\n                    }\n                    // Quoted string\n                    if (c === '\"') {\n                        read(++i);\n                        while (i < columnStr.length) {\n                            if (c === '\"') {\n                                break;\n                            }\n                            token += c;\n                            read(++i);\n                        }\n                    }\n                    else if (c === itemDelimiter) {\n                        push();\n                        // Actual column data\n                    }\n                    else {\n                        token += c;\n                    }\n                }\n                push();\n            }\n            /**\n             * Internal method that guesses the delimiter from the first\n             * 13 lines of the CSV\n             * @param {Array<string>} lines\n             * The CSV, split into lines\n             */\n            guessDelimiter(lines) {\n                let points = 0, commas = 0, guessed;\n                const potDelimiters = {\n                    ',': 0,\n                    ';': 0,\n                    '\\t': 0\n                }, linesCount = lines.length;\n                for (let i = 0; i < linesCount; i++) {\n                    let inStr = false, c, cn, cl, token = '';\n                    // We should be able to detect dateformats within 13 rows\n                    if (i > 13) {\n                        break;\n                    }\n                    const columnStr = lines[i];\n                    for (let j = 0; j < columnStr.length; j++) {\n                        c = columnStr[j];\n                        cn = columnStr[j + 1];\n                        cl = columnStr[j - 1];\n                        if (c === '#') {\n                            // Skip the rest of the line - it's a comment\n                            break;\n                        }\n                        if (c === '\"') {\n                            if (inStr) {\n                                if (cl !== '\"' && cn !== '\"') {\n                                    while (cn === ' ' && j < columnStr.length) {\n                                        cn = columnStr[++j];\n                                    }\n                                    // After parsing a string, the next non-blank\n                                    // should be a delimiter if the CSV is properly\n                                    // formed.\n                                    if (typeof potDelimiters[cn] !== 'undefined') {\n                                        potDelimiters[cn]++;\n                                    }\n                                    inStr = false;\n                                }\n                            }\n                            else {\n                                inStr = true;\n                            }\n                        }\n                        else if (typeof potDelimiters[c] !== 'undefined') {\n                            token = token.trim();\n                            if (!isNaN(Date.parse(token))) {\n                                potDelimiters[c]++;\n                            }\n                            else if (isNaN(Number(token)) ||\n                                !isFinite(Number(token))) {\n                                potDelimiters[c]++;\n                            }\n                            token = '';\n                        }\n                        else {\n                            token += c;\n                        }\n                        if (c === ',') {\n                            commas++;\n                        }\n                        if (c === '.') {\n                            points++;\n                        }\n                    }\n                }\n                // Count the potential delimiters.\n                // This could be improved by checking if the number of delimiters\n                // equals the number of columns - 1\n                if (potDelimiters[';'] > potDelimiters[',']) {\n                    guessed = ';';\n                }\n                else if (potDelimiters[','] > potDelimiters[';']) {\n                    guessed = ',';\n                }\n                else {\n                    // No good guess could be made..\n                    guessed = ',';\n                }\n                // Try to deduce the decimal point if it's not explicitly set.\n                // If both commas or points is > 0 there is likely an issue\n                if (points > commas) {\n                    this.guessedDecimalPoint = '.';\n                }\n                else {\n                    this.guessedDecimalPoint = ',';\n                }\n                return guessed;\n            }\n            /**\n             * Handles converting the parsed data to a table.\n             *\n             * @return {DataTable}\n             * Table from the parsed CSV.\n             */\n            getTable() {\n                return DataConverter.getTableFromColumns(this.columns, this.headers);\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options\n         */\n        CSVConverter.defaultOptions = {\n            ...DataConverter.defaultOptions,\n            lineDelimiter: '\\n'\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return CSVConverter;\n    });\n    _registerModule(_modules, 'Data/Connectors/CSVConnector.js', [_modules['Data/Converters/CSVConverter.js'], _modules['Data/Connectors/DataConnector.js'], _modules['Core/Utilities.js']], function (CSVConverter, DataConnector, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Torstein HÃ¸nsi\n         *  - Christer Vasseng\n         *  - GÃ¸ran Slettemark\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Class that handles creating a DataConnector from CSV\n         *\n         * @private\n         */\n        class CSVConnector extends DataConnector {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of CSVConnector.\n             *\n             * @param {CSVConnector.UserOptions} [options]\n             * Options for the connector and converter.\n             */\n            constructor(options) {\n                const mergedOptions = merge(CSVConnector.defaultOptions, options);\n                super(mergedOptions);\n                this.converter = new CSVConverter(mergedOptions);\n                this.options = mergedOptions;\n                if (mergedOptions.enablePolling) {\n                    this.startPolling(Math.max(mergedOptions.dataRefreshRate || 0, 1) * 1000);\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initiates the loading of the CSV source to the connector\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits CSVConnector#load\n             * @emits CSVConnector#afterLoad\n             */\n            load(eventDetail) {\n                const connector = this, converter = connector.converter, table = connector.table, { csv, csvURL, dataModifier } = connector.options;\n                connector.emit({\n                    type: 'load',\n                    csv,\n                    detail: eventDetail,\n                    table\n                });\n                return Promise\n                    .resolve(csvURL ?\n                    fetch(csvURL).then((response) => response.text()) :\n                    csv || '')\n                    .then((csv) => {\n                    if (csv) {\n                        // If already loaded, clear the current rows\n                        table.deleteColumns();\n                        converter.parse({ csv });\n                        table.setColumns(converter.getTable().getColumns());\n                    }\n                    return connector\n                        .setModifierOptions(dataModifier)\n                        .then(() => csv);\n                })\n                    .then((csv) => {\n                    connector.emit({\n                        type: 'afterLoad',\n                        csv,\n                        detail: eventDetail,\n                        table\n                    });\n                    return connector;\n                })['catch']((error) => {\n                    connector.emit({\n                        type: 'loadError',\n                        detail: eventDetail,\n                        error,\n                        table\n                    });\n                    throw error;\n                });\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        CSVConnector.defaultOptions = {\n            csv: '',\n            csvURL: '',\n            enablePolling: false,\n            dataRefreshRate: 1,\n            firstRowAsNames: true\n        };\n        DataConnector.registerType('CSV', CSVConnector);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return CSVConnector;\n    });\n    _registerModule(_modules, 'Data/Converters/JSONConverter.js', [_modules['Data/Converters/DataConverter.js'], _modules['Data/DataTable.js'], _modules['Core/Utilities.js']], function (DataConverter, DataTable, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Pawel Lysy\n         *\n         * */\n        const { error, isArray, merge, objectEach } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Handles parsing and transforming JSON to a table.\n         *\n         * @private\n         */\n        class JSONConverter extends DataConverter {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the JSON parser.\n             *\n             * @param {JSONConverter.UserOptions} [options]\n             * Options for the JSON parser.\n             */\n            constructor(options) {\n                const mergedOptions = merge(JSONConverter.defaultOptions, options);\n                super(mergedOptions);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.columns = [];\n                this.headers = [];\n                this.options = mergedOptions;\n                this.table = new DataTable();\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initiates parsing of JSON structure.\n             *\n             * @param {JSONConverter.UserOptions}[options]\n             * Options for the parser\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits JSONConverter#parse\n             * @emits JSONConverter#afterParse\n             */\n            parse(options, eventDetail) {\n                const converter = this;\n                options = merge(converter.options, options);\n                const { beforeParse, orientation, firstRowAsNames, columnNames } = options;\n                let data = options.data;\n                if (!data) {\n                    return;\n                }\n                converter.columns = [];\n                converter.emit({\n                    type: 'parse',\n                    columns: converter.columns,\n                    detail: eventDetail,\n                    headers: converter.headers\n                });\n                if (beforeParse) {\n                    data = beforeParse(data);\n                }\n                data = data.slice();\n                if (orientation === 'columns') {\n                    for (let i = 0, iEnd = data.length; i < iEnd; i++) {\n                        const item = data[i];\n                        if (!(item instanceof Array)) {\n                            return;\n                        }\n                        if (converter.headers instanceof Array) {\n                            if (firstRowAsNames) {\n                                converter.headers.push(`${item.shift()}`);\n                            }\n                            else if (columnNames && columnNames instanceof Array) {\n                                converter.headers.push(columnNames[i]);\n                            }\n                            converter.table.setColumn(converter.headers[i] || i.toString(), item);\n                        }\n                        else {\n                            error('JSONConverter: Invalid `columnNames` option.', false);\n                        }\n                    }\n                }\n                else if (orientation === 'rows') {\n                    if (firstRowAsNames) {\n                        converter.headers = data.shift();\n                    }\n                    else if (columnNames) {\n                        converter.headers = columnNames;\n                    }\n                    for (let rowIndex = 0, iEnd = data.length; rowIndex < iEnd; rowIndex++) {\n                        let row = data[rowIndex];\n                        if (isArray(row)) {\n                            for (let columnIndex = 0, jEnd = row.length; columnIndex < jEnd; columnIndex++) {\n                                if (converter.columns.length < columnIndex + 1) {\n                                    converter.columns.push([]);\n                                }\n                                converter.columns[columnIndex].push(row[columnIndex]);\n                                if (converter.headers instanceof Array) {\n                                    this.table.setColumn(converter.headers[columnIndex] ||\n                                        columnIndex.toString(), converter.columns[columnIndex]);\n                                }\n                                else {\n                                    error('JSONConverter: Invalid `columnNames` option.', false);\n                                }\n                            }\n                        }\n                        else {\n                            const columnNames = converter.headers;\n                            if (columnNames && !(columnNames instanceof Array)) {\n                                const newRow = {};\n                                objectEach(columnNames, (arrayWithPath, name) => {\n                                    newRow[name] = arrayWithPath.reduce((acc, key) => acc[key], row);\n                                });\n                                row = newRow;\n                            }\n                            this.table.setRows([row], rowIndex);\n                        }\n                    }\n                }\n                converter.emit({\n                    type: 'afterParse',\n                    columns: converter.columns,\n                    detail: eventDetail,\n                    headers: converter.headers\n                });\n            }\n            /**\n             * Handles converting the parsed data to a table.\n             *\n             * @return {DataTable}\n             * Table from the parsed CSV.\n             */\n            getTable() {\n                return this.table;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options\n         */\n        JSONConverter.defaultOptions = {\n            ...DataConverter.defaultOptions,\n            data: [],\n            orientation: 'rows'\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return JSONConverter;\n    });\n    _registerModule(_modules, 'Data/Connectors/JSONConnector.js', [_modules['Data/Connectors/DataConnector.js'], _modules['Core/Utilities.js'], _modules['Data/Converters/JSONConverter.js']], function (DataConnector, U, JSONConverter) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Pawel Lysy\n         *\n         * */\n        const { merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Class that handles creating a DataConnector from JSON structure\n         *\n         * @private\n         */\n        class JSONConnector extends DataConnector {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of JSONConnector.\n             *\n             * @param {JSONConnector.UserOptions} [options]\n             * Options for the connector and converter.\n             */\n            constructor(options) {\n                const mergedOptions = merge(JSONConnector.defaultOptions, options);\n                super(mergedOptions);\n                this.converter = new JSONConverter(mergedOptions);\n                this.options = mergedOptions;\n                if (mergedOptions.enablePolling) {\n                    this.startPolling(Math.max(mergedOptions.dataRefreshRate || 0, 1) * 1000);\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initiates the loading of the JSON source to the connector\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits JSONConnector#load\n             * @emits JSONConnector#afterLoad\n             */\n            load(eventDetail) {\n                const connector = this, converter = connector.converter, table = connector.table, { data, dataUrl, dataModifier } = connector.options;\n                connector.emit({\n                    type: 'load',\n                    data,\n                    detail: eventDetail,\n                    table\n                });\n                return Promise\n                    .resolve(dataUrl ?\n                    fetch(dataUrl).then((json) => json.json()) :\n                    data || [])\n                    .then((data) => {\n                    if (data) {\n                        // If already loaded, clear the current rows\n                        table.deleteColumns();\n                        converter.parse({ data });\n                        table.setColumns(converter.getTable().getColumns());\n                        table.setRowKeysColumn(data.length);\n                    }\n                    return connector.setModifierOptions(dataModifier).then(() => data);\n                })\n                    .then((data) => {\n                    connector.emit({\n                        type: 'afterLoad',\n                        data,\n                        detail: eventDetail,\n                        table\n                    });\n                    return connector;\n                })['catch']((error) => {\n                    connector.emit({\n                        type: 'loadError',\n                        detail: eventDetail,\n                        error,\n                        table\n                    });\n                    throw error;\n                });\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        JSONConnector.defaultOptions = {\n            data: [],\n            enablePolling: false,\n            dataRefreshRate: 0,\n            firstRowAsNames: true,\n            orientation: 'rows'\n        };\n        DataConnector.registerType('JSON', JSONConnector);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return JSONConnector;\n    });\n    _registerModule(_modules, 'Data/Converters/GoogleSheetsConverter.js', [_modules['Data/Converters/DataConverter.js'], _modules['Core/Utilities.js']], function (DataConverter, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Torstein HÃ¸nsi\n         *  - GÃ¸ran Slettemark\n         *  - Wojciech Chmiel\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge, uniqueKey } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Handles parsing and transformation of an Google Sheets to a table.\n         *\n         * @private\n         */\n        class GoogleSheetsConverter extends DataConverter {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the GoogleSheetsConverter.\n             *\n             * @param {GoogleSheetsConverter.UserOptions} [options]\n             * Options for the GoogleSheetsConverter.\n             */\n            constructor(options) {\n                const mergedOptions = merge(GoogleSheetsConverter.defaultOptions, options);\n                super(mergedOptions);\n                this.columns = [];\n                this.header = [];\n                this.options = mergedOptions;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Initiates the parsing of the Google Sheet\n             *\n             * @param {GoogleSheetsConverter.UserOptions}[options]\n             * Options for the parser\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits GoogleSheetsParser#parse\n             * @emits GoogleSheetsParser#afterParse\n             */\n            parse(options, eventDetail) {\n                const converter = this, parseOptions = merge(converter.options, options);\n                let columns = ((parseOptions.json?.values) || []).map((column) => column.slice());\n                if (columns.length === 0) {\n                    return false;\n                }\n                converter.header = [];\n                converter.columns = [];\n                converter.emit({\n                    type: 'parse',\n                    columns: converter.columns,\n                    detail: eventDetail,\n                    headers: converter.header\n                });\n                // If beforeParse is defined, use it to modify the data\n                const { beforeParse, json } = parseOptions;\n                if (beforeParse && json) {\n                    columns = beforeParse(json.values);\n                }\n                let column;\n                converter.columns = columns;\n                for (let i = 0, iEnd = columns.length; i < iEnd; i++) {\n                    column = columns[i];\n                    converter.header[i] = (parseOptions.firstRowAsNames ?\n                        `${column.shift()}` :\n                        uniqueKey());\n                    for (let j = 0, jEnd = column.length; j < jEnd; ++j) {\n                        if (column[j] && typeof column[j] === 'string') {\n                            let cellValue = converter.asGuessedType(column[j]);\n                            if (cellValue instanceof Date) {\n                                cellValue = cellValue.getTime();\n                            }\n                            converter.columns[i][j] = cellValue;\n                        }\n                    }\n                }\n                converter.emit({\n                    type: 'afterParse',\n                    columns: converter.columns,\n                    detail: eventDetail,\n                    headers: converter.header\n                });\n            }\n            /**\n             * Handles converting the parsed data to a table.\n             *\n             * @return {DataTable}\n             * Table from the parsed Google Sheet\n             */\n            getTable() {\n                return DataConverter.getTableFromColumns(this.columns, this.header);\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options\n         */\n        GoogleSheetsConverter.defaultOptions = {\n            ...DataConverter.defaultOptions\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GoogleSheetsConverter;\n    });\n    _registerModule(_modules, 'Data/Connectors/GoogleSheetsConnector.js', [_modules['Data/Connectors/DataConnector.js'], _modules['Data/Converters/GoogleSheetsConverter.js'], _modules['Core/Utilities.js']], function (DataConnector, GoogleSheetsConverter, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Torstein HÃ¸nsi\n         *  - GÃ¸ran Slettemark\n         *  - Wojciech Chmiel\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge, pick } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Tests Google's response for error.\n         * @private\n         */\n        function isGoogleError(json) {\n            return (typeof json === 'object' && json &&\n                typeof json.error === 'object' && json.error &&\n                typeof json.error.code === 'number' &&\n                typeof json.error.message === 'string' &&\n                typeof json.error.status === 'string');\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * @private\n         * @todo implement save, requires oauth2\n         */\n        class GoogleSheetsConnector extends DataConnector {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of GoogleSheetsConnector\n             *\n             * @param {GoogleSheetsConnector.UserOptions} [options]\n             * Options for the connector and converter.\n             */\n            constructor(options) {\n                const mergedOptions = merge(GoogleSheetsConnector.defaultOptions, options);\n                super(mergedOptions);\n                this.converter = new GoogleSheetsConverter(mergedOptions);\n                this.options = mergedOptions;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Loads data from a Google Spreadsheet.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Promise<this>}\n             * Same connector instance with modified table.\n             */\n            load(eventDetail) {\n                const connector = this, converter = connector.converter, table = connector.table, { dataModifier, dataRefreshRate, enablePolling, firstRowAsNames, googleAPIKey, googleSpreadsheetKey } = connector.options, url = GoogleSheetsConnector.buildFetchURL(googleAPIKey, googleSpreadsheetKey, connector.options);\n                connector.emit({\n                    type: 'load',\n                    detail: eventDetail,\n                    table,\n                    url\n                });\n                return fetch(url)\n                    .then((response) => (response.json()))\n                    .then((json) => {\n                    if (isGoogleError(json)) {\n                        throw new Error(json.error.message);\n                    }\n                    converter.parse({\n                        firstRowAsNames,\n                        json\n                    });\n                    // If already loaded, clear the current table\n                    table.deleteColumns();\n                    table.setColumns(converter.getTable().getColumns());\n                    return connector.setModifierOptions(dataModifier);\n                })\n                    .then(() => {\n                    connector.emit({\n                        type: 'afterLoad',\n                        detail: eventDetail,\n                        table,\n                        url\n                    });\n                    // Polling\n                    if (enablePolling) {\n                        setTimeout(() => connector.load(), Math.max(dataRefreshRate || 0, 1) * 1000);\n                    }\n                    return connector;\n                })['catch']((error) => {\n                    connector.emit({\n                        type: 'loadError',\n                        detail: eventDetail,\n                        error,\n                        table\n                    });\n                    throw error;\n                });\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        GoogleSheetsConnector.defaultOptions = {\n            googleAPIKey: '',\n            googleSpreadsheetKey: '',\n            worksheet: 1,\n            enablePolling: false,\n            dataRefreshRate: 2,\n            firstRowAsNames: true\n        };\n        /* *\n         *\n         *  Class Namespace\n         *\n         * */\n        (function (GoogleSheetsConnector) {\n            /* *\n             *\n             *  Declarations\n             *\n             * */\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Creates GoogleSheets API v4 URL.\n             * @private\n             */\n            function buildFetchURL(apiKey, sheetKey, options = {}) {\n                return (`https://sheets.googleapis.com/v4/spreadsheets/${sheetKey}/values/` +\n                    (options.onlyColumnNames ?\n                        'A1:Z1' :\n                        buildQueryRange(options)) +\n                    '?alt=json' +\n                    (options.onlyColumnNames ?\n                        '' :\n                        '&dateTimeRenderOption=FORMATTED_STRING' +\n                            '&majorDimension=COLUMNS' +\n                            '&valueRenderOption=UNFORMATTED_VALUE') +\n                    '&prettyPrint=false' +\n                    `&key=${apiKey}`);\n            }\n            GoogleSheetsConnector.buildFetchURL = buildFetchURL;\n            /**\n             * Creates sheets range.\n             * @private\n             */\n            function buildQueryRange(options = {}) {\n                const { endColumn, endRow, googleSpreadsheetRange, startColumn, startRow } = options;\n                return googleSpreadsheetRange || ((alphabet[startColumn || 0] || 'A') +\n                    (Math.max((startRow || 0), 0) + 1) +\n                    ':' +\n                    (alphabet[pick(endColumn, 25)] || 'Z') +\n                    (endRow ?\n                        Math.max(endRow, 0) :\n                        'Z'));\n            }\n            GoogleSheetsConnector.buildQueryRange = buildQueryRange;\n        })(GoogleSheetsConnector || (GoogleSheetsConnector = {}));\n        DataConnector.registerType('GoogleSheets', GoogleSheetsConnector);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return GoogleSheetsConnector;\n    });\n    _registerModule(_modules, 'Data/Converters/HTMLTableConverter.js', [_modules['Data/Converters/DataConverter.js'], _modules['Core/Utilities.js']], function (DataConverter, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Torstein HÃ¸nsi\n         *  - GÃ¸ran Slettemark\n         *  - Wojciech Chmiel\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge } = U;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * Row equal\n         */\n        function isRowEqual(row1, row2) {\n            let i = row1.length;\n            if (row2.length === i) {\n                while (--i) {\n                    if (row1[i] !== row2[i]) {\n                        return false;\n                    }\n                }\n            }\n            else {\n                return false;\n            }\n            return true;\n        }\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Handles parsing and transformation of an HTML table to a table.\n         *\n         * @private\n         */\n        class HTMLTableConverter extends DataConverter {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the HTMLTableConverter.\n             *\n             * @param {HTMLTableConverter.UserOptions} [options]\n             * Options for the HTMLTableConverter.\n             */\n            constructor(options) {\n                const mergedOptions = merge(HTMLTableConverter.defaultOptions, options);\n                super(mergedOptions);\n                this.columns = [];\n                this.headers = [];\n                this.options = mergedOptions;\n                if (mergedOptions.tableElement) {\n                    this.tableElement = mergedOptions.tableElement;\n                    this.tableElementID = mergedOptions.tableElement.id;\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Exports the dataconnector as an HTML string, using the options\n             * provided on      *\n             * @param {DataConnector} connector\n             * Connector instance to export from.\n             *\n             * @param {HTMLTableConnector.ExportOptions} [options]\n             * Options that override default or existing export options.\n             *\n             * @return {string}\n             * HTML from the current dataTable.\n             */\n            export(connector, options = this.options) {\n                const exportNames = (options.firstRowAsNames !== false), useMultiLevelHeaders = options.useMultiLevelHeaders;\n                const columns = connector.getSortedColumns(options.usePresentationOrder), columnNames = Object.keys(columns), htmlRows = [], columnsCount = columnNames.length;\n                const rowArray = [];\n                let tableHead = '';\n                // Add the names as the first row if they should be exported\n                if (exportNames) {\n                    const subcategories = [];\n                    // If using multilevel headers, the first value\n                    // of each column is a subcategory\n                    if (useMultiLevelHeaders) {\n                        for (const name of columnNames) {\n                            const subhead = (columns[name].shift() || '').toString();\n                            subcategories.push(subhead);\n                        }\n                        tableHead = this.getTableHeaderHTML(columnNames, subcategories, options);\n                    }\n                    else {\n                        tableHead = this.getTableHeaderHTML(void 0, columnNames, options);\n                    }\n                }\n                for (let columnIndex = 0; columnIndex < columnsCount; columnIndex++) {\n                    const columnName = columnNames[columnIndex], column = columns[columnName], columnLength = column.length;\n                    for (let rowIndex = 0; rowIndex < columnLength; rowIndex++) {\n                        let cellValue = column[rowIndex];\n                        if (!rowArray[rowIndex]) {\n                            rowArray[rowIndex] = [];\n                        }\n                        // Alternative: Datatype from HTML attribute with\n                        // connector.whatIs(columnName)\n                        if (!(typeof cellValue === 'string' ||\n                            typeof cellValue === 'number' ||\n                            typeof cellValue === 'undefined')) {\n                            cellValue = (cellValue || '').toString();\n                        }\n                        rowArray[rowIndex][columnIndex] = this.getCellHTMLFromValue(columnIndex ? 'td' : 'th', null, columnIndex ? '' : 'scope=\"row\"', cellValue);\n                        // On the final column, push the row to the array\n                        if (columnIndex === columnsCount - 1) {\n                            htmlRows.push('<tr>' +\n                                rowArray[rowIndex].join('') +\n                                '</tr>');\n                        }\n                    }\n                }\n                let caption = '';\n                // Add table caption\n                // Current exportdata falls back to chart title\n                // but that should probably be handled elsewhere?\n                if (options.tableCaption) {\n                    caption = '<caption class=\"highcharts-table-caption\">' +\n                        options.tableCaption +\n                        '</caption>';\n                }\n                return ('<table>' +\n                    caption +\n                    tableHead +\n                    '<tbody>' +\n                    htmlRows.join('') +\n                    '</tbody>' +\n                    '</table>');\n            }\n            /**\n             * Get table cell markup from row data.\n             */\n            getCellHTMLFromValue(tag, classes, attrs, value, decimalPoint) {\n                let val = value, className = 'text' + (classes ? ' ' + classes : '');\n                // Convert to string if number\n                if (typeof val === 'number') {\n                    val = val.toString();\n                    if (decimalPoint === ',') {\n                        val = val.replace('.', decimalPoint);\n                    }\n                    className = 'number';\n                }\n                else if (!value) {\n                    val = '';\n                    className = 'empty';\n                }\n                return '<' + tag + (attrs ? ' ' + attrs : '') +\n                    ' class=\"' + className + '\">' +\n                    val + '</' + tag + '>';\n            }\n            /**\n             * Get table header markup from row data.\n             */\n            getTableHeaderHTML(topheaders = [], subheaders = [], options = this.options) {\n                const { useMultiLevelHeaders, useRowspanHeaders } = options;\n                let html = '<thead>', i = 0, len = subheaders && subheaders.length, next, cur, curColspan = 0, rowspan;\n                // Clean up multiple table headers. Chart.getDataRows() returns two\n                // levels of headers when using multilevel, not merged. We need to\n                // merge identical headers, remove redundant headers, and keep it\n                // all marked up nicely.\n                if (useMultiLevelHeaders &&\n                    topheaders &&\n                    subheaders &&\n                    !isRowEqual(topheaders, subheaders)) {\n                    html += '<tr>';\n                    for (; i < len; ++i) {\n                        cur = topheaders[i];\n                        next = topheaders[i + 1];\n                        if (cur === next) {\n                            ++curColspan;\n                        }\n                        else if (curColspan) {\n                            // Ended colspan\n                            // Add cur to HTML with colspan.\n                            html += this.getCellHTMLFromValue('th', 'highcharts-table-topheading', 'scope=\"col\" ' +\n                                'colspan=\"' + (curColspan + 1) + '\"', cur);\n                            curColspan = 0;\n                        }\n                        else {\n                            // Cur is standalone. If it is same as sublevel,\n                            // remove sublevel and add just toplevel.\n                            if (cur === subheaders[i]) {\n                                if (useRowspanHeaders) {\n                                    rowspan = 2;\n                                    delete subheaders[i];\n                                }\n                                else {\n                                    rowspan = 1;\n                                    subheaders[i] = '';\n                                }\n                            }\n                            else {\n                                rowspan = 1;\n                            }\n                            html += this.getCellHTMLFromValue('th', 'highcharts-table-topheading', 'scope=\"col\"' +\n                                (rowspan > 1 ?\n                                    ' valign=\"top\" rowspan=\"' + rowspan + '\"' :\n                                    ''), cur);\n                        }\n                    }\n                    html += '</tr>';\n                }\n                // Add the subheaders (the only headers if not using multilevels)\n                if (subheaders) {\n                    html += '<tr>';\n                    for (i = 0, len = subheaders.length; i < len; ++i) {\n                        if (typeof subheaders[i] !== 'undefined') {\n                            html += this.getCellHTMLFromValue('th', null, 'scope=\"col\"', subheaders[i]);\n                        }\n                    }\n                    html += '</tr>';\n                }\n                html += '</thead>';\n                return html;\n            }\n            /**\n             * Initiates the parsing of the HTML table\n             *\n             * @param {HTMLTableConverter.UserOptions}[options]\n             * Options for the parser\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits CSVDataParser#parse\n             * @emits CSVDataParser#afterParse\n             * @emits HTMLTableParser#parseError\n             */\n            parse(options, eventDetail) {\n                const converter = this, columns = [], headers = [], parseOptions = merge(converter.options, options), { endRow, startColumn, endColumn, firstRowAsNames } = parseOptions, tableHTML = parseOptions.tableElement || this.tableElement;\n                if (!(tableHTML instanceof HTMLElement)) {\n                    converter.emit({\n                        type: 'parseError',\n                        columns,\n                        detail: eventDetail,\n                        headers,\n                        error: 'Not a valid HTML Table'\n                    });\n                    return;\n                }\n                converter.tableElement = tableHTML;\n                converter.tableElementID = tableHTML.id;\n                this.emit({\n                    type: 'parse',\n                    columns: converter.columns,\n                    detail: eventDetail,\n                    headers: converter.headers\n                });\n                const rows = tableHTML.getElementsByTagName('tr'), rowsCount = rows.length;\n                let rowIndex = 0, item, { startRow } = parseOptions;\n                // Insert headers from the first row\n                if (firstRowAsNames && rowsCount) {\n                    const items = rows[0].children, itemsLength = items.length;\n                    for (let i = startColumn; i < itemsLength; i++) {\n                        if (i > endColumn) {\n                            break;\n                        }\n                        item = items[i];\n                        if (item.tagName === 'TD' ||\n                            item.tagName === 'TH') {\n                            headers.push(item.innerHTML);\n                        }\n                    }\n                    startRow++;\n                }\n                while (rowIndex < rowsCount) {\n                    if (rowIndex >= startRow && rowIndex <= endRow) {\n                        const columnsInRow = rows[rowIndex].children, columnsInRowLength = columnsInRow.length;\n                        let columnIndex = 0;\n                        while (columnIndex < columnsInRowLength) {\n                            const relativeColumnIndex = columnIndex - startColumn, row = columns[relativeColumnIndex];\n                            item = columnsInRow[columnIndex];\n                            if ((item.tagName === 'TD' ||\n                                item.tagName === 'TH') &&\n                                (columnIndex >= startColumn &&\n                                    columnIndex <= endColumn)) {\n                                if (!columns[relativeColumnIndex]) {\n                                    columns[relativeColumnIndex] = [];\n                                }\n                                let cellValue = converter.asGuessedType(item.innerHTML);\n                                if (cellValue instanceof Date) {\n                                    cellValue = cellValue.getTime();\n                                }\n                                columns[relativeColumnIndex][rowIndex - startRow] = cellValue;\n                                // Loop over all previous indices and make sure\n                                // they are nulls, not undefined.\n                                let i = 1;\n                                while (rowIndex - startRow >= i &&\n                                    row[rowIndex - startRow - i] === void 0) {\n                                    row[rowIndex - startRow - i] = null;\n                                    i++;\n                                }\n                            }\n                            columnIndex++;\n                        }\n                    }\n                    rowIndex++;\n                }\n                this.columns = columns;\n                this.headers = headers;\n                this.emit({\n                    type: 'afterParse',\n                    columns,\n                    detail: eventDetail,\n                    headers\n                });\n            }\n            /**\n             * Handles converting the parsed data to a table.\n             *\n             * @return {DataTable}\n             * Table from the parsed HTML table\n             */\n            getTable() {\n                return DataConverter.getTableFromColumns(this.columns, this.headers);\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options\n         */\n        HTMLTableConverter.defaultOptions = {\n            ...DataConverter.defaultOptions,\n            useRowspanHeaders: true,\n            useMultiLevelHeaders: true\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return HTMLTableConverter;\n    });\n    _registerModule(_modules, 'Data/Connectors/HTMLTableConnector.js', [_modules['Data/Connectors/DataConnector.js'], _modules['Core/Globals.js'], _modules['Data/Converters/HTMLTableConverter.js'], _modules['Core/Utilities.js']], function (DataConnector, H, HTMLTableConverter, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Torstein HÃ¸nsi\n         *  - GÃ¸ran Slettemark\n         *  - Wojciech Chmiel\n         *  - Sophie Bremer\n         *\n         * */\n        const { win } = H;\n        const { merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Class that handles creating a data connector from an HTML table.\n         *\n         * @private\n         */\n        class HTMLTableConnector extends DataConnector {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of HTMLTableConnector.\n             *\n             * @param {HTMLTableConnector.UserOptions} [options]\n             * Options for the connector and converter.\n             */\n            constructor(options) {\n                const mergedOptions = merge(HTMLTableConnector.defaultOptions, options);\n                super(mergedOptions);\n                this.converter = new HTMLTableConverter(mergedOptions);\n                this.options = mergedOptions;\n            }\n            /**\n             * Initiates creating the dataconnector from the HTML table\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @emits HTMLTableConnector#load\n             * @emits HTMLTableConnector#afterLoad\n             * @emits HTMLTableConnector#loadError\n             */\n            load(eventDetail) {\n                const connector = this, converter = connector.converter, table = connector.table, { dataModifier, table: tableHTML } = connector.options;\n                connector.emit({\n                    type: 'load',\n                    detail: eventDetail,\n                    table,\n                    tableElement: connector.tableElement\n                });\n                let tableElement;\n                if (typeof tableHTML === 'string') {\n                    connector.tableID = tableHTML;\n                    tableElement = win.document.getElementById(tableHTML);\n                }\n                else {\n                    tableElement = tableHTML;\n                    connector.tableID = tableElement.id;\n                }\n                connector.tableElement = tableElement || void 0;\n                if (!connector.tableElement) {\n                    const error = 'HTML table not provided, or element with ID not found';\n                    connector.emit({\n                        type: 'loadError',\n                        detail: eventDetail,\n                        error,\n                        table\n                    });\n                    return Promise.reject(new Error(error));\n                }\n                converter.parse(merge({ tableElement: connector.tableElement }, connector.options), eventDetail);\n                // If already loaded, clear the current rows\n                table.deleteColumns();\n                table.setColumns(converter.getTable().getColumns());\n                return connector\n                    .setModifierOptions(dataModifier)\n                    .then(() => {\n                    connector.emit({\n                        type: 'afterLoad',\n                        detail: eventDetail,\n                        table,\n                        tableElement: connector.tableElement\n                    });\n                    return connector;\n                });\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        HTMLTableConnector.defaultOptions = {\n            table: ''\n        };\n        DataConnector.registerType('HTMLTable', HTMLTableConnector);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return HTMLTableConnector;\n    });\n    _registerModule(_modules, 'Data/Modifiers/ChainModifier.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Core/Utilities.js']], function (DataModifier, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Modifies a table with the help of modifiers in an ordered chain.\n         *\n         */\n        class ChainModifier extends DataModifier {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the modifier chain.\n             *\n             * @param {Partial<ChainModifier.Options>} [options]\n             * Options to configure the modifier chain.\n             *\n             * @param {...DataModifier} [chain]\n             * Ordered chain of modifiers.\n             */\n            constructor(options, ...chain) {\n                super();\n                this.chain = chain;\n                this.options = merge(ChainModifier.defaultOptions, options);\n                const optionsChain = this.options.chain || [];\n                for (let i = 0, iEnd = optionsChain.length, modifierOptions, ModifierClass; i < iEnd; ++i) {\n                    modifierOptions = optionsChain[i];\n                    if (!modifierOptions.type) {\n                        continue;\n                    }\n                    ModifierClass = DataModifier.types[modifierOptions.type];\n                    if (ModifierClass) {\n                        chain.push(new ModifierClass(modifierOptions));\n                    }\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Adds a configured modifier to the end of the modifier chain. Please note,\n             * that the modifier can be added multiple times.\n             *\n             * @param {DataModifier} modifier\n             * Configured modifier to add.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             */\n            add(modifier, eventDetail) {\n                this.emit({\n                    type: 'addModifier',\n                    detail: eventDetail,\n                    modifier\n                });\n                this.chain.push(modifier);\n                this.emit({\n                    type: 'addModifier',\n                    detail: eventDetail,\n                    modifier\n                });\n            }\n            /**\n             * Clears all modifiers from the chain.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             */\n            clear(eventDetail) {\n                this.emit({\n                    type: 'clearChain',\n                    detail: eventDetail\n                });\n                this.chain.length = 0;\n                this.emit({\n                    type: 'afterClearChain',\n                    detail: eventDetail\n                });\n            }\n            /**\n             * Applies several modifications to the table and returns a modified copy of\n             * the given table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to modify.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Promise<Highcharts.DataTable>}\n             * Table with `modified` property as a reference.\n             */\n            modify(table, eventDetail) {\n                const modifiers = (this.options.reverse ?\n                    this.chain.slice().reverse() :\n                    this.chain.slice());\n                if (table.modified === table) {\n                    table.modified = table.clone(false, eventDetail);\n                }\n                let promiseChain = Promise.resolve(table);\n                for (let i = 0, iEnd = modifiers.length; i < iEnd; ++i) {\n                    const modifier = modifiers[i];\n                    promiseChain = promiseChain.then((chainTable) => modifier.modify(chainTable.modified, eventDetail));\n                }\n                promiseChain = promiseChain.then((chainTable) => {\n                    table.modified.deleteColumns();\n                    table.modified.setColumns(chainTable.modified.getColumns());\n                    return table;\n                });\n                promiseChain = promiseChain['catch']((error) => {\n                    this.emit({\n                        type: 'error',\n                        detail: eventDetail,\n                        table\n                    });\n                    throw error;\n                });\n                return promiseChain;\n            }\n            /**\n             * Applies partial modifications of a cell change to the property `modified`\n             * of the given modified table.\n             *\n             * *Note:* The `modified` property of the table gets replaced.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {string} columnName\n             * Column name of changed cell.\n             *\n             * @param {number|undefined} rowIndex\n             * Row index of changed cell.\n             *\n             * @param {Highcharts.DataTableCellType} cellValue\n             * Changed cell value.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyCell(table, columnName, rowIndex, cellValue, eventDetail) {\n                const modifiers = (this.options.reverse ?\n                    this.chain.reverse() :\n                    this.chain);\n                if (modifiers.length) {\n                    let clone = table.clone();\n                    for (let i = 0, iEnd = modifiers.length; i < iEnd; ++i) {\n                        modifiers[i].modifyCell(clone, columnName, rowIndex, cellValue, eventDetail);\n                        clone = clone.modified;\n                    }\n                    table.modified = clone;\n                }\n                return table;\n            }\n            /**\n             * Applies partial modifications of column changes to the property\n             * `modified` of the given table.\n             *\n             * *Note:* The `modified` property of the table gets replaced.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {Highcharts.DataTableColumnCollection} columns\n             * Changed columns as a collection, where the keys are the column names.\n             *\n             * @param {number} [rowIndex=0]\n             * Index of the first changed row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyColumns(table, columns, rowIndex, eventDetail) {\n                const modifiers = (this.options.reverse ?\n                    this.chain.reverse() :\n                    this.chain.slice());\n                if (modifiers.length) {\n                    let clone = table.clone();\n                    for (let i = 0, iEnd = modifiers.length; i < iEnd; ++i) {\n                        modifiers[i].modifyColumns(clone, columns, rowIndex, eventDetail);\n                        clone = clone.modified;\n                    }\n                    table.modified = clone;\n                }\n                return table;\n            }\n            /**\n             * Applies partial modifications of row changes to the property `modified`\n             * of the given table.\n             *\n             * *Note:* The `modified` property of the table gets replaced.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n             * Changed rows.\n             *\n             * @param {number} [rowIndex]\n             * Index of the first changed row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyRows(table, rows, rowIndex, eventDetail) {\n                const modifiers = (this.options.reverse ?\n                    this.chain.reverse() :\n                    this.chain.slice());\n                if (modifiers.length) {\n                    let clone = table.clone();\n                    for (let i = 0, iEnd = modifiers.length; i < iEnd; ++i) {\n                        modifiers[i].modifyRows(clone, rows, rowIndex, eventDetail);\n                        clone = clone.modified;\n                    }\n                    table.modified = clone;\n                }\n                return table;\n            }\n            /**\n             * Applies several modifications to the table.\n             *\n             * *Note:* The `modified` property of the table gets replaced.\n             *\n             * @param {DataTable} table\n             * Table to modify.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {DataTable}\n             * Table as a reference.\n             *\n             * @emits ChainDataModifier#execute\n             * @emits ChainDataModifier#afterExecute\n             */\n            modifyTable(table, eventDetail) {\n                const chain = this;\n                chain.emit({\n                    type: 'modify',\n                    detail: eventDetail,\n                    table\n                });\n                const modifiers = (chain.options.reverse ?\n                    chain.chain.reverse() :\n                    chain.chain.slice());\n                let modified = table.modified;\n                for (let i = 0, iEnd = modifiers.length, modifier; i < iEnd; ++i) {\n                    modifier = modifiers[i];\n                    modified = modifier.modifyTable(modified, eventDetail).modified;\n                }\n                table.modified = modified;\n                chain.emit({\n                    type: 'afterModify',\n                    detail: eventDetail,\n                    table\n                });\n                return table;\n            }\n            /**\n             * Removes a configured modifier from all positions in the modifier chain.\n             *\n             * @param {DataModifier} modifier\n             * Configured modifier to remove.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             */\n            remove(modifier, eventDetail) {\n                const modifiers = this.chain;\n                this.emit({\n                    type: 'removeModifier',\n                    detail: eventDetail,\n                    modifier\n                });\n                modifiers.splice(modifiers.indexOf(modifier), 1);\n                this.emit({\n                    type: 'afterRemoveModifier',\n                    detail: eventDetail,\n                    modifier\n                });\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default option for the ordered modifier chain.\n         */\n        ChainModifier.defaultOptions = {\n            type: 'Chain'\n        };\n        DataModifier.registerType('Chain', ChainModifier);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return ChainModifier;\n    });\n    _registerModule(_modules, 'Data/Modifiers/InvertModifier.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Core/Utilities.js']], function (DataModifier, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Wojciech Chmiel\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Inverts columns and rows in a table.\n         *\n         * @private\n         */\n        class InvertModifier extends DataModifier {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the invert modifier.\n             *\n             * @param {Partial<InvertModifier.Options>} [options]\n             * Options to configure the invert modifier.\n             */\n            constructor(options) {\n                super();\n                this.options = merge(InvertModifier.defaultOptions, options);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Applies partial modifications of a cell change to the property `modified`\n             * of the given modified table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {string} columnName\n             * Column name of changed cell.\n             *\n             * @param {number|undefined} rowIndex\n             * Row index of changed cell.\n             *\n             * @param {Highcharts.DataTableCellType} cellValue\n             * Changed cell value.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyCell(table, columnName, rowIndex, cellValue, eventDetail) {\n                const modified = table.modified, modifiedRowIndex = modified.getRowIndexBy('columnNames', columnName);\n                if (typeof modifiedRowIndex === 'undefined') {\n                    modified.setColumns(this.modifyTable(table.clone()).getColumns(), void 0, eventDetail);\n                }\n                else {\n                    modified.setCell(`${rowIndex}`, modifiedRowIndex, cellValue, eventDetail);\n                }\n                return table;\n            }\n            /**\n             * Applies partial modifications of column changes to the property\n             * `modified` of the given table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {Highcharts.DataTableColumnCollection} columns\n             * Changed columns as a collection, where the keys are the column names.\n             *\n             * @param {number} [rowIndex=0]\n             * Index of the first changed row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyColumns(table, columns, rowIndex, eventDetail) {\n                const modified = table.modified, modifiedColumnNames = (modified.getColumn('columnNames') || []);\n                let columnNames = table.getColumnNames(), reset = (table.getRowCount() !== modifiedColumnNames.length);\n                if (!reset) {\n                    for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                        if (columnNames[i] !== modifiedColumnNames[i]) {\n                            reset = true;\n                            break;\n                        }\n                    }\n                }\n                if (reset) {\n                    return this.modifyTable(table, eventDetail);\n                }\n                columnNames = Object.keys(columns);\n                for (let i = 0, iEnd = columnNames.length, column, columnName, modifiedRowIndex; i < iEnd; ++i) {\n                    columnName = columnNames[i];\n                    column = columns[columnName];\n                    modifiedRowIndex = (modified.getRowIndexBy('columnNames', columnName) ||\n                        modified.getRowCount());\n                    for (let j = 0, j2 = rowIndex, jEnd = column.length; j < jEnd; ++j, ++j2) {\n                        modified.setCell(`${j2}`, modifiedRowIndex, column[j], eventDetail);\n                    }\n                }\n                return table;\n            }\n            /**\n             * Applies partial modifications of row changes to the property `modified`\n             * of the given table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n             * Changed rows.\n             *\n             * @param {number} [rowIndex]\n             * Index of the first changed row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyRows(table, rows, rowIndex, eventDetail) {\n                const columnNames = table.getColumnNames(), modified = table.modified, modifiedColumnNames = (modified.getColumn('columnNames') || []);\n                let reset = (table.getRowCount() !== modifiedColumnNames.length);\n                if (!reset) {\n                    for (let i = 0, iEnd = columnNames.length; i < iEnd; ++i) {\n                        if (columnNames[i] !== modifiedColumnNames[i]) {\n                            reset = true;\n                            break;\n                        }\n                    }\n                }\n                if (reset) {\n                    return this.modifyTable(table, eventDetail);\n                }\n                for (let i = 0, i2 = rowIndex, iEnd = rows.length, row; i < iEnd; ++i, ++i2) {\n                    row = rows[i];\n                    if (row instanceof Array) {\n                        modified.setColumn(`${i2}`, row);\n                    }\n                    else {\n                        for (let j = 0, jEnd = columnNames.length; j < jEnd; ++j) {\n                            modified.setCell(`${i2}`, j, row[columnNames[j]], eventDetail);\n                        }\n                    }\n                }\n                return table;\n            }\n            /**\n             * Inverts rows and columns in the table.\n             *\n             * @param {DataTable} table\n             * Table to invert.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {DataTable}\n             * Table with inverted `modified` property as a reference.\n             */\n            modifyTable(table, eventDetail) {\n                const modifier = this;\n                modifier.emit({ type: 'modify', detail: eventDetail, table });\n                const modified = table.modified;\n                if (table.hasColumns(['columnNames'])) { // Inverted table\n                    const columnNames = ((table.deleteColumns(['columnNames']) || {})\n                        .columnNames || []).map((column) => `${column}`), columns = {};\n                    for (let i = 0, iEnd = table.getRowCount(), row; i < iEnd; ++i) {\n                        row = table.getRow(i);\n                        if (row) {\n                            columns[columnNames[i]] = row;\n                        }\n                    }\n                    modified.deleteColumns();\n                    modified.setColumns(columns);\n                }\n                else { // Regular table\n                    const columns = {};\n                    for (let i = 0, iEnd = table.getRowCount(), row; i < iEnd; ++i) {\n                        row = table.getRow(i);\n                        if (row) {\n                            columns[`${i}`] = row;\n                        }\n                    }\n                    columns.columnNames = table.getColumnNames();\n                    modified.deleteColumns();\n                    modified.setColumns(columns);\n                }\n                modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n                return table;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options for the invert modifier.\n         */\n        InvertModifier.defaultOptions = {\n            type: 'Invert'\n        };\n        DataModifier.registerType('Invert', InvertModifier);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return InvertModifier;\n    });\n    _registerModule(_modules, 'Data/Modifiers/MathModifier.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Data/Formula/FormulaParser.js'], _modules['Data/Formula/FormulaProcessor.js']], function (DataModifier, FormulaParser, FormulaProcessor) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Replaces formula strings in a table with calculated values.\n         *\n         * @class\n         * @name Highcharts.DataModifier.types.MathModifier\n         * @augments Highcharts.DataModifier\n         */\n        class MathModifier extends DataModifier {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(options) {\n                super();\n                this.options = {\n                    ...MathModifier.defaultOptions,\n                    ...options\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            modifyTable(table, eventDetail) {\n                const modifier = this;\n                modifier.emit({ type: 'modify', detail: eventDetail, table });\n                const alternativeSeparators = modifier.options.alternativeSeparators, formulaColumns = (modifier.options.formulaColumns ||\n                    table.getColumnNames()), modified = table.modified;\n                for (let i = 0, iEnd = formulaColumns.length, columnName; i < iEnd; ++i) {\n                    columnName = formulaColumns[i];\n                    if (formulaColumns.indexOf(columnName) >= 0) {\n                        modified.setColumn(columnName, modifier.processColumn(table, columnName));\n                    }\n                }\n                const columnFormulas = (modifier.options.columnFormulas || []);\n                for (let i = 0, iEnd = columnFormulas.length, columnFormula, formula; i < iEnd; ++i) {\n                    columnFormula = columnFormulas[i];\n                    formula = FormulaParser.parseFormula(columnFormula.formula, alternativeSeparators);\n                    modified.setColumn(columnFormula.column, modifier.processColumnFormula(formula, table, columnFormula.rowStart, columnFormula.rowEnd));\n                }\n                modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n                return table;\n            }\n            /**\n             * Process a column by replacing formula strings with calculated values.\n             *\n             * @private\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to extract column from and use as reference.\n             *\n             * @param {string} columnNameOrAlias\n             * Name or alias of column to process.\n             *\n             * @param {number} rowIndex\n             * Row index to start the replacing process from.\n             *\n             * @return {Highcharts.DataTableColumn}\n             * Returns the processed table column.\n             */\n            processColumn(table, columnNameOrAlias, rowIndex = 0) {\n                const alternativeSeparators = this.options.alternativeSeparators, column = (table.getColumn(columnNameOrAlias, true) || [])\n                    .slice(rowIndex > 0 ? rowIndex : 0);\n                for (let i = 0, iEnd = column.length, cacheFormula = [], cacheString = '', cell; i < iEnd; ++i) {\n                    cell = column[i];\n                    if (typeof cell === 'string' &&\n                        cell[0] === '=') {\n                        try {\n                            // Use cache while formula string is repetitive\n                            cacheFormula = (cacheString === cell ?\n                                cacheFormula :\n                                FormulaParser.parseFormula(cell.substring(1), alternativeSeparators));\n                            // Process parsed formula string\n                            column[i] =\n                                FormulaProcessor.processFormula(cacheFormula, table);\n                        }\n                        catch {\n                            column[i] = NaN;\n                        }\n                    }\n                }\n                return column;\n            }\n            /**\n             * Process a column by replacing cell values with calculated values from a\n             * given formula.\n             *\n             * @private\n             *\n             * @param {Highcharts.Formula} formula\n             * Formula to use for processing.\n             *\n             * @param {Highcharts.DataTable} table\n             * Table to extract column from and use as reference.\n             *\n             * @param {number} rowStart\n             * Row index to start the replacing process from.\n             *\n             * @param {number} rowEnd\n             * Row index to end the replacing process.\n             *\n             * @return {Highcharts.DataTableColumn}\n             * Returns the processed table column.\n             */\n            processColumnFormula(formula, table, rowStart = 0, rowEnd = table.getRowCount()) {\n                rowStart = rowStart >= 0 ? rowStart : 0;\n                rowEnd = rowEnd >= 0 ? rowEnd : table.getRowCount() + rowEnd;\n                const column = [], modified = table.modified;\n                for (let i = 0, iEnd = (rowEnd - rowStart); i < iEnd; ++i) {\n                    try {\n                        column[i] = FormulaProcessor.processFormula(formula, modified);\n                    }\n                    catch {\n                        column[i] = NaN;\n                    }\n                    finally {\n                        formula = FormulaProcessor.translateReferences(formula, 0, 1);\n                    }\n                }\n                return column;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options of MathModifier.\n         * @private\n         */\n        MathModifier.defaultOptions = {\n            type: 'Math',\n            alternativeSeparators: false\n        };\n        DataModifier.registerType('Math', MathModifier);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return MathModifier;\n    });\n    _registerModule(_modules, 'Data/Modifiers/RangeModifier.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Core/Utilities.js']], function (DataModifier, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Filters out table rows with a specific value range.\n         *\n         */\n        class RangeModifier extends DataModifier {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the range modifier.\n             *\n             * @param {Partial<RangeModifier.Options>} [options]\n             * Options to configure the range modifier.\n             */\n            constructor(options) {\n                super();\n                this.options = merge(RangeModifier.defaultOptions, options);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Replaces table rows with filtered rows.\n             *\n             * @param {DataTable} table\n             * Table to modify.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyTable(table, eventDetail) {\n                const modifier = this;\n                modifier.emit({ type: 'modify', detail: eventDetail, table });\n                const { additive, ranges, strict } = modifier.options;\n                if (ranges.length) {\n                    const modified = table.modified;\n                    let columns = table.getColumns(), rows = [];\n                    for (let i = 0, iEnd = ranges.length, range, rangeColumn; i < iEnd; ++i) {\n                        range = ranges[i];\n                        if (strict &&\n                            typeof range.minValue !== typeof range.maxValue) {\n                            continue;\n                        }\n                        if (i > 0 && !additive) {\n                            modified.deleteRows();\n                            modified.setRows(rows);\n                            columns = modified.getColumns();\n                            rows = [];\n                        }\n                        rangeColumn = (columns[range.column] || []);\n                        for (let j = 0, jEnd = rangeColumn.length, cell, row; j < jEnd; ++j) {\n                            cell = rangeColumn[j];\n                            switch (typeof cell) {\n                                default:\n                                    continue;\n                                case 'boolean':\n                                case 'number':\n                                case 'string':\n                                    break;\n                            }\n                            if (strict &&\n                                typeof cell !== typeof range.minValue) {\n                                continue;\n                            }\n                            if (cell >= range.minValue &&\n                                cell <= range.maxValue) {\n                                row = (additive ?\n                                    table.getRow(j) :\n                                    modified.getRow(j));\n                                if (row) {\n                                    rows.push(row);\n                                }\n                            }\n                        }\n                    }\n                    modified.deleteRows();\n                    modified.setRows(rows);\n                }\n                modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n                return table;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options for the range modifier.\n         */\n        RangeModifier.defaultOptions = {\n            type: 'Range',\n            ranges: []\n        };\n        DataModifier.registerType('Range', RangeModifier);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return RangeModifier;\n    });\n    _registerModule(_modules, 'Data/Modifiers/SortModifier.js', [_modules['Data/Modifiers/DataModifier.js'], _modules['Data/DataTable.js'], _modules['Core/Utilities.js']], function (DataModifier, DataTable, U) {\n        /* *\n         *\n         *  (c) 2009-2024 Highsoft AS\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         *  Authors:\n         *  - Sophie Bremer\n         *\n         * */\n        const { merge } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Sort table rows according to values of a column.\n         *\n         */\n        class SortModifier extends DataModifier {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            static ascending(a, b) {\n                return ((a || 0) < (b || 0) ? -1 :\n                    (a || 0) > (b || 0) ? 1 :\n                        0);\n            }\n            static descending(a, b) {\n                return ((b || 0) < (a || 0) ? -1 :\n                    (b || 0) > (a || 0) ? 1 :\n                        0);\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            /**\n             * Constructs an instance of the range modifier.\n             *\n             * @param {Partial<RangeDataModifier.Options>} [options]\n             * Options to configure the range modifier.\n             */\n            constructor(options) {\n                super();\n                this.options = merge(SortModifier.defaultOptions, options);\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Returns index and row for sort reference.\n             *\n             * @private\n             *\n             * @param {Highcharts.DataTable} table\n             * Table with rows to reference.\n             *\n             * @return {Array<SortModifier.RowReference>}\n             * Array of row references.\n             */\n            getRowReferences(table) {\n                const rows = table.getRows(), rowReferences = [];\n                for (let i = 0, iEnd = rows.length; i < iEnd; ++i) {\n                    rowReferences.push({\n                        index: i,\n                        row: rows[i]\n                    });\n                }\n                return rowReferences;\n            }\n            /**\n             * Applies partial modifications of a cell change to the property `modified`\n             * of the given modified table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {string} columnName\n             * Column name of changed cell.\n             *\n             * @param {number|undefined} rowIndex\n             * Row index of changed cell.\n             *\n             * @param {Highcharts.DataTableCellType} cellValue\n             * Changed cell value.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyCell(table, columnName, rowIndex, cellValue, eventDetail) {\n                const modifier = this, { orderByColumn, orderInColumn } = modifier.options;\n                if (columnName === orderByColumn) {\n                    if (orderInColumn) {\n                        table.modified.setCell(columnName, rowIndex, cellValue);\n                        table.modified.setColumn(orderInColumn, modifier\n                            .modifyTable(new DataTable({\n                            columns: table\n                                .getColumns([orderByColumn, orderInColumn])\n                        }))\n                            .modified\n                            .getColumn(orderInColumn));\n                    }\n                    else {\n                        modifier.modifyTable(table, eventDetail);\n                    }\n                }\n                return table;\n            }\n            /**\n             * Applies partial modifications of column changes to the property\n             * `modified` of the given table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {Highcharts.DataTableColumnCollection} columns\n             * Changed columns as a collection, where the keys are the column names.\n             *\n             * @param {number} [rowIndex=0]\n             * Index of the first changed row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyColumns(table, columns, rowIndex, eventDetail) {\n                const modifier = this, { orderByColumn, orderInColumn } = modifier.options, columnNames = Object.keys(columns);\n                if (columnNames.indexOf(orderByColumn) > -1) {\n                    if (orderInColumn &&\n                        columns[columnNames[0]].length) {\n                        table.modified.setColumns(columns, rowIndex);\n                        table.modified.setColumn(orderInColumn, modifier\n                            .modifyTable(new DataTable({\n                            columns: table\n                                .getColumns([orderByColumn, orderInColumn])\n                        }))\n                            .modified\n                            .getColumn(orderInColumn));\n                    }\n                    else {\n                        modifier.modifyTable(table, eventDetail);\n                    }\n                }\n                return table;\n            }\n            /**\n             * Applies partial modifications of row changes to the property `modified`\n             * of the given table.\n             *\n             * @param {Highcharts.DataTable} table\n             * Modified table.\n             *\n             * @param {Array<(Highcharts.DataTableRow|Highcharts.DataTableRowObject)>} rows\n             * Changed rows.\n             *\n             * @param {number} [rowIndex]\n             * Index of the first changed row.\n             *\n             * @param {Highcharts.DataTableEventDetail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {Highcharts.DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyRows(table, rows, rowIndex, eventDetail) {\n                const modifier = this, { orderByColumn, orderInColumn } = modifier.options;\n                if (orderInColumn &&\n                    rows.length) {\n                    table.modified.setRows(rows, rowIndex);\n                    table.modified.setColumn(orderInColumn, modifier\n                        .modifyTable(new DataTable({\n                        columns: table\n                            .getColumns([orderByColumn, orderInColumn])\n                    }))\n                        .modified\n                        .getColumn(orderInColumn));\n                }\n                else {\n                    modifier.modifyTable(table, eventDetail);\n                }\n                return table;\n            }\n            /**\n             * Sorts rows in the table.\n             *\n             * @param {DataTable} table\n             * Table to sort in.\n             *\n             * @param {DataEvent.Detail} [eventDetail]\n             * Custom information for pending events.\n             *\n             * @return {DataTable}\n             * Table with `modified` property as a reference.\n             */\n            modifyTable(table, eventDetail) {\n                const modifier = this;\n                modifier.emit({ type: 'modify', detail: eventDetail, table });\n                const columnNames = table.getColumnNames(), rowCount = table.getRowCount(), rowReferences = this.getRowReferences(table), { direction, orderByColumn, orderInColumn } = modifier.options, compare = (direction === 'asc' ?\n                    SortModifier.ascending :\n                    SortModifier.descending), orderByColumnIndex = columnNames.indexOf(orderByColumn), modified = table.modified;\n                if (orderByColumnIndex !== -1) {\n                    rowReferences.sort((a, b) => compare(a.row[orderByColumnIndex], b.row[orderByColumnIndex]));\n                }\n                if (orderInColumn) {\n                    const column = [];\n                    for (let i = 0; i < rowCount; ++i) {\n                        column[rowReferences[i].index] = i;\n                    }\n                    modified.setColumns({ [orderInColumn]: column });\n                }\n                else {\n                    const rows = [];\n                    for (let i = 0; i < rowCount; ++i) {\n                        rows.push(rowReferences[i].row);\n                    }\n                    modified.setRows(rows, 0);\n                }\n                modifier.emit({ type: 'afterModify', detail: eventDetail, table });\n                return table;\n            }\n        }\n        /* *\n         *\n         *  Static Properties\n         *\n         * */\n        /**\n         * Default options to group table rows.\n         */\n        SortModifier.defaultOptions = {\n            type: 'Sort',\n            direction: 'desc',\n            orderByColumn: 'y'\n        };\n        DataModifier.registerType('Sort', SortModifier);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return SortModifier;\n    });\n    _registerModule(_modules, 'masters/modules/data-tools.src.js', [_modules['Core/Globals.js'], _modules['Data/Connectors/DataConnector.js'], _modules['Data/Converters/DataConverter.js'], _modules['Data/DataCursor.js'], _modules['Data/Modifiers/DataModifier.js'], _modules['Data/DataPool.js'], _modules['Data/DataTable.js'], _modules['Data/Formula/Formula.js']], function (Highcharts, DataConnector, DataConverter, DataCursor, DataModifier, DataPool, DataTable, Formula) {\n\n        const G = Highcharts;\n        G.DataConnector = G.DataConnector || DataConnector;\n        G.DataConverter = G.DataConverter || DataConverter;\n        G.DataCursor = G.DataCursor || DataCursor;\n        G.DataModifier = G.DataModifier || DataModifier;\n        G.DataPool = G.DataPool || DataPool;\n        G.DataTable = G.DataTable || DataTable;\n        G.Formula = G.Formula || Formula;\n\n        return Highcharts;\n    });\n}));\n"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","win","dispatchEvent","detail","U","DataModifier","addEvent","fireEvent","merge","benchmark","dataTable","options","results","modifier","execute","modifyTable","emit","type","iterations","on","length","times","startTime","endTime","window","performance","now","push","e","modify","table","eventDetail","Promise","resolve","reject","modified","clone","modifyCell","columnName","rowIndex","cellValue","modifyColumns","columns","modifyRows","rows","callback","types","registerType","key","DataModifierClass","uniqueKey","DataTable","isNull","row","NULL","Array","i","iEnd","columnNames","Object","keys","constructor","aliases","JSON","parse","stringify","autoId","id","rowCount","versionTag","rowKeysId","thisColumns","column","slice","Math","max","aliasKeys","thisAliases","alias","setRowKeysColumn","skipColumns","tableOptions","tableClone","deleteColumnAlias","deletedAlias","deleteColumns","deletedColumns","modifiedColumns","nColumns","deleteRows","deletedRows","modifiedRows","deletedCells","splice","j","jEnd","getCell","columnNameOrAlias","getCellAsBoolean","getCellAsNumber","useNaN","isNaN","parseFloat","getCellAsString","getColumn","asReference","getColumns","getColumnAsNumbers","columnAsNumber","columnLength","getColumnNames","removeRowKeysColumn","columnNamesOrAliases","tableAliasMap","tableColumns","getModifier","getRow","getRows","getRowCount","getRowIndexBy","rowIndexOffset","indexOf","getRowObject","getRowObjects","i2","min","getVersionTag","hasColumns","hasRowWith","renameColumn","newColumnName","moveRowKeysColumnToLast","setCell","setColumn","setColumns","tableModifier","reset","tableColumn","tableColumnNames","nRows","keysArray","getRowKeysColumn","getRowIndexOriginal","idx","idxOrig","rowKeyCol","split","String","setModifier","promise","then","error","setRow","setRows","rowColumnNames","rowColumnName","indexRowCount","includes","rowKeyColumn","pos","pop","version","DataConnector","pick","metadata","polling","describeColumn","name","columnMeta","connector","describeColumns","getColumnOrder","usePresentationState","names","sort","a","b","index","getSortedColumns","usePresentationOrder","load","save","Error","setColumnOrder","setModifierOptions","modifierOptions","ModifierClass","startPolling","refreshTime","clearTimeout","_polling","setTimeout","stopPolling","whatIs","DataConnectorClass","isNumber","DataConverter","dateFormats","regex","parser","match","Date","UTC","NaN","alternative","d","year","getFullYear","mergedOptions","defaultOptions","regExpPoint","decimalPoint","decimalRegExp","RegExp","asBoolean","value","asNumber","asDate","timestamp","parseDate","asString","asGuessedType","typeMap","converter","guessType","call","decimalRegex","replace","test","getDate","deduceDateFormat","data","limit","stable","format","thing","guessedFormat","madeDeduction","elem","trim","parseInt","join","dateFormat","export","headers","getTable","result","trimedValue","innerTrimedValue","floatValue","dateFormatProp","getTime","getTimezoneOffset","str","inside","alternativeFormat","startColumn","endColumn","Number","MAX_VALUE","startRow","endRow","firstRowAsNames","switchRowsAndColumns","getTableFromColumns","DataCursor","stateMap","emittingRegister","listenerMap","addListener","tableId","state","listener","listeners","buildEmittingTag","cursor","firstRow","lastRow","emitCursor","event","lasting","cursors","getIndex","emittingTag","remitCursor","removeListener","toRange","defaultRange","range","needle","columnNeedle","isEqual","cursorA","cursorB","isInRange","needleColumns","rangeColumns","every","toPositions","positions","rowEnd","columnEnd","connectors","DataPoolDefaults","DataPool","waiting","getConnector","connectorId","waitingList","connectorOptions","getConnectorOptions","loadConnector","getConnectorIds","connectorIds","getConnectorTable","isNewConnector","ConnectorClass","setConnectorOptions","instances","booleanRegExp","decimal1RegExp","decimal2RegExp","functionRegExp","operatorRegExp","rangeA1RegExp","rangeR1C1RegExp","referenceA1RegExp","referenceR1C1RegExp","extractParantheses","text","parantheseLevel","char","parantheseStart","substring","extractString","start","escaping","parseArgument","alternativeSeparators","beginColumnRelative","beginRowRelative","endColumnRelative","endRowRelative","beginColumn","beginRow","parseReferenceColumn","formula","parseFormula","next","columnRelative","rowRelative","reference","string","parantheses","parseArguments","argumentsSeparator","term","paranteses","position","code","factor","charCodeAt","pow","operators","isFormula","item","isFunction","isOperator","isRange","isReference","isValue","FormulaTypes","asLogicalStringRegExp","MAX_FALSE","MAX_STRING","MAX_TRUE","operatorPriority","processorFunctions","processorFunctionNameRegExp","asLogicalNumber","asLogicalString","toLowerCase","basicOperation","operator","x","y","round","getArgumentValue","arg","getRangeValues","processFunction","processFormula","values","cell","cells","getReferenceValue","operator2","formulaFunction","processor","getArgumentsValues","registerProcessorFunction","processorFunction","translateReferences","columnDelta","rowDelta","FormulaProcessor","ABS","abs","value2","AND","AVERAGE","count","AVERAGEA","COUNT","COUNTA","IF","ISNA","MAX","NEGATIVE_INFINITY","isFinite","MEDIAN","median","half","floor","MIN","POSITIVE_INFINITY","MOD","value1","getModeMap","modeMap","MULT","modeKeys","modeCount","SNGL","modeKey","keyValue","NOT","OR","PRODUCT","calculated","SUM","XOR","lastValue","FormulaParser","FormulaType","CSVConverter","dataTypes","useLocalDecimalPoint","lineDelimiter","exportNames","itemDelimiter","toLocaleString","csvRows","columnsCount","rowArray","map","columnIndex","columnDataType","dataType","cellVal","parserOptions","beforeParse","lines","rowIt","csv","guessedItemDelimiter","guessDelimiter","offset","parseCSVRow","columnStr","rowNumber","guessedDecimalPoint","c","token","actualColumn","read","pushType","initialValue","points","commas","guessed","potDelimiters","linesCount","inStr","cn","cl","CSVConnector","enablePolling","dataRefreshRate","csvURL","dataModifier","fetch","response","isArray","objectEach","JSONConverter","orientation","shift","toString","newRow","arrayWithPath","reduce","acc","JSONConnector","dataUrl","json","GoogleSheetsConverter","header","parseOptions","GoogleSheetsConnector","googleAPIKey","googleSpreadsheetKey","url","buildFetchURL","message","status","worksheet","alphabet","buildQueryRange","googleSpreadsheetRange","apiKey","sheetKey","onlyColumnNames","HTMLTableConverter","tableElement","tableElementID","useMultiLevelHeaders","htmlRows","tableHead","subcategories","subhead","getTableHeaderHTML","getCellHTMLFromValue","caption","tableCaption","tag","classes","attrs","val","className","topheaders","subheaders","useRowspanHeaders","html","len","cur","curColspan","rowspan","isRowEqual","row1","row2","tableHTML","HTMLElement","getElementsByTagName","rowsCount","items","children","itemsLength","tagName","innerHTML","columnsInRow","columnsInRowLength","relativeColumnIndex","H","HTMLTableConnector","tableID","document","getElementById","ChainModifier","chain","optionsChain","add","clear","modifiers","reverse","promiseChain","chainTable","remove","InvertModifier","modifiedRowIndex","modifiedColumnNames","j2","MathModifier","formulaColumns","processColumn","columnFormulas","columnFormula","processColumnFormula","rowStart","cacheFormula","cacheString","RangeModifier","additive","ranges","strict","rangeColumn","minValue","maxValue","SortModifier","ascending","descending","getRowReferences","rowReferences","orderByColumn","orderInColumn","direction","compare","orderByColumnIndex","Formula","G"],"rangeMappings":";;;;;;;;","mappings":"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"}